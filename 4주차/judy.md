## 17장. 경계: 선긋기

> 소프트웨어 아키텍처는 선을 긋는 기술, 이러한 선을 경계라고 부른다.
> 
> 
> 경계는 소프트웨어 요소를 서로 분리하고, 경계 한편에 있는 요소가 반대편에 있는 요소를 알지 못하도록 막는다.
> 

프로젝트 초기에 그어진 선은 가능한 오랫동안 결정을 연기시키기 위해, 그래서 이들 결정이 핵심적인 업무 로직을 오염시키지 못하도록 만들려는 목적으로 쓰인다.

아키텍트의 목표는 인적 자원을 최소화하는 것이다. 인적 자원의 효율을 떨어뜨리는 요인은 바로 결합(coupling)이다. 특히 **너무 일찍 내려진 결정에 따른 결합**이다.

> **이른 결정**: 시스템의 업무 요구사항, 즉 유스케이스와 관련없는 프레임워크, 데이터베이스, 웹 서버, 유틸리티 라이브러리, 의존성 주입등을 결정하는 것을 말함
> 

좋은 시스템 아키텍처는 결정에 의존X, 결정을 가능한 한 최후의 순간에 내리며 결정에 따른 영향이 크지 않다.

### 두 가지 슬픈 이야기

- P사 : 너무 이른 결정에는 위험이 따른다. 아키텍트가 너무 이르게 결정을 내림으로써 개발 비용을 엄청나게 가중시킨 사례다.

원래 데스크톱 기반의 제품을 자바를 사용한 웹 애플리케이션으로 전환하려 했으나, 세 가지 계층(사용자 인터페이스, 비즈니스 로직, 데이터베이스)각각에 대한 인스턴스를 별도로 유지하고 복잡한 통신 과정을 거치는 3-티어 아키텍처를 선택함으로써, 실제 사용 환경과 맞지 않는 오버헤드와 성능 저하를 경험하게 되었다.

이로 인해 개발 비용이 크게 증가하고, 시스템 설계시 실제 사용 사례를 고려하는 것의 중요성을 강조하는 사례가 되었다.

- W사 : SOA(service-oriented Architecture: 서비스 지향 아키텍처)를 약속하는 일련의 도구들을 너무 일찍 채택하여 적용함에 따라 인적 시간의 비용이 올라갔다.

엔터프라이즈급 서비스 지향 아키텍처(SOA)를 도입했으나, 이로 인해 개발자들이 복잡한 도메인 모델과 서비스 간 강한 결합을 관리해야 했다. 테스트와 시스템 변경은 다수의 서비스 및 시스템 구성 요소를 동시에 구동해야 하며, WSDL(Web Services Description Language)의 지속적인 변경과 재배포가 필요했다. 이는 SOA의 성급한 적용이 비용과 복잡성을 증가시키고, 프로젝트의 성공 가능성을 낮출 수 있음을 보여준다. 

### **FitNesse**

1. FitNesse의 요구에 특화된 우리만의 웹서버를 직접 작성하자

기본 뼈대만 갖춘 웹 서버는 단일 소프트웨어이기에 구현이 간단하고 어떤 웹 프로그램워크를 사용할지에 대한 결정을 훨씬 나중으로 연기할 수 있었다.

2. 데이터베이스에 대해 고민하지 말자

어떤 데이터베이스를 사용하더라도 상관 없도록 설계하여 의도적으로 데이터베이스에 대한 결정을 미뤘다. 우리는 모든 데이터 접근 영역과 데이터 저장소 영역 사이에 인터페이스를 추가하는 간단한 설계 방식을 사용했다.

자그마치 18개월 동안 데이터베이스가 없다는 사실은 스키마와 관련된 문제들, 쿼리 문제들, 데이터베이스 서버 문제들, 패스워드 문제들 그리고 데이터베이스를 작동시킬 때 추하게 고개를 드는 여타 모든 고약한 문제가 없었다는 사실을 뜻한다.

테스트를 느리게 만드는 데이터베이스가 없으니 테스트 또한 빠르게 돌릴 수 있었다.

간단히 말해서 경계선을 긋는 행위는 결정을 늦추고 연기하는 데 도움이 되었고, 궁극적으로는 시간을 엄청나게 절약해주었으며, 골치를 썩지 않게해주었다.

### 어떻게 선을 그을까? 그리고 언제 그을까?

> 선은 관련있는것과 없는것 사이에 긋는다. ⇒ 흔히 얘기하는 관심사의 분리라고 생각이 듦.
> 
1. GUI는 업무 규칙과는 관련 없기 때문에, 이 둘 사이에는 반드시 선이 있어야 한다.
2. 데이터베이스는 GUI와는 관련이 없으므로, 이 둘 사이에도 반드시 선이 있어야 한다.
3. 데이터 베이스는 업무 규칙과 관련 없으므로, 이 둘 사이에도 선이 있어야 한다.

**데이터베이스는 업무 규칙이 간접적으로 사용할 수 있는 도구**다. 업무 규칙은 스키마, 쿼리 언어, 또는 데이터베이스와 관련된 나머지 세부사항에 대해 어떤 것도 알아서는 안된다. 업무 규칙이 알아야 할 것은 데이터를 가져오고 저장할 때 사용할 수 있는 함수 집합이 있다는 사실이다. 

아래의 그림에서 보면 BusinessRules는 Database Interface를 사용하여 데이터를 로드하고 저장한다. DatabaseAccess는 DatabaseInterface를 구현하며, Database를 실제로 조작하는 일을 맡는다.

<p align="center">
<img width="431" style="text-align: center;" alt="image" src="https://github.com/FrontendStudySeoul/cleanArchitecture/assets/70371342/ada06153-9e82-4a07-a6e6-6d833f22baee">
</p>

경계선은 Interface, Database Access사이에 그어진다. 

Database Access에서 출발하는 두 화살표에 집중 → 이 도표에서 Database Access가 존재한다는 사실을 알고 있는 클래스는 없다는 뜻이다.

> 비즈니스 규칙, 데이터베이스가 서로 다른 계층으로 분리되어야 한다는 점을 강조한다고 생각.
> 

<p align="center">
<img width="430" alt="image" src="https://github.com/FrontendStudySeoul/cleanArchitecture/assets/70371342/e0507e8a-78ca-45a5-8827-e734713266a9">
</p>

큰 개념에서 보게되면 

Database는 Business Rules에 대해 알고 있지만, Business Rules는 Database에 관해 알지 못한다. 이는 DatabaseInterface 클래스는 BusinessRules 컴포넌트에 속하며, DatabaseAccess클래스는 Database 컴포넌트에 속한다는 사실을 의미한다.

Business Rules 컴포넌트에게 있어 Database 컴포넌트는 문제가 되지 않지만, 그러나 Business Rules 컴포넌트의 호출을 쿼리언어로 변환하는 코드를 Database 컴포넌트가 담고있기때문에 Database 컴포넌트는 Business Rules 컴포넌트 없이 존재할 수 없다.

화살표 방향은 Business Rules 컴포넌트를 향하고있기 때문에 Database 컴포넌트는 다른 구현체로도 교체될 수 있음.

- 앞서 말했다시피 데이터베이스에 대한 결정 연기가능.
- 업무규칙 작성, 테스트에 집중 가능.

> 비즈니스 규칙 계층이 데이터베이스 계층에 직접 접근하지 않고, 데이터베이스 인터페이스를 거쳐 데이터를 주고받도록 설계된 것을 강조. 이는 계층 간의 결합도를 낮추고 유지보수성을 향상시키는 방법임을 시사하고 있다.
> 

### 입력과 출력은?

개발자와 고객은 종종 시스템이 무엇인지에 대해 혼란스러워한다. GUI를 보고선 GUI가 시스템이라고 생각하곤한다.

우리는 시스템의 행위를 입출력이 지닌 행위적 측면에서 생각하는 경향이 있다. 예를 들어 비디오게임에서 사용자 경험은 인터페이스에 의해 좌우된다. 화면, 마우스, 버튼, 음향이 바로 그 인터페이스다.

이러한 인터페이스 뒤에는 인터페이스를 조작하는 모델(데이터 구조와 함수로 구성된 정교한 집합)이 존재한다는 사실을 잊어버린다. 더 중요한 사실은 모델은 인터페이스가 필요하지 않다. 화면에 출력되지 않아도 돌아가는데 문제가 없다.

위의 Business Rules 컴포넌트와 Databse 컴포넌트의 관계와 같이 Business 컴포넌트는 GUI 컴포넌트를 신경쓰지 않는다.

<p align="center">
<img width="435" alt="image" src="https://github.com/FrontendStudySeoul/cleanArchitecture/assets/70371342/6f9547d2-71ef-4823-b17d-195d2e04b3da">
</p>

GUI와 BusinessRules 컴포넌트 사이의 경계

GUI와 BusinessRules 컴포넌트가 경계선에 의해 분할된다는 사실을 알 수 있다. GUI는 다른 종류의 인터페이스로 얼마든지 교체할 수 있다.

> 즉, GUI와 비즈니스 로직이 분리되어야 함을 시사하고 있다.
> 

### 플러그인 아키텍처

데이터베이스와 GUI에 대해 내린 두 가지 결정을 하나로 합쳐서 보면 컴포넌트 추가와 관련한 일종의 패턴이 만들어진다. **이 패턴은 시스템에서 서드 파티 플러그인을 사용할 수 있게 한** 바로 그 패턴과 동일하다.

<p align="center">
<img width="430" alt="image" src="https://github.com/FrontendStudySeoul/cleanArchitecture/assets/70371342/37f4fae9-8896-4629-b0de-405d166d9786">
</p>

업무 규칙에 플러그인 형태로 연결하기

이 설계에서 사용자 인터페이스는 플러그인 형태로 고려되었기에, 수많은 종류의 사용자 인터페이스를 플러그인 형태로 연결할 수 있게 된다.

GUI는 사용자의 입력과 상호 작용을 담당하고, 비즈니스 규칙 계층은 이 입력을 바탕으로 필요한 로직을 처리하고 데이터베이스와의 통신을 관리한다. 이렇게 계층을 나누는 이유는 유지보수와 확장성을 높이고, 시스템의 각 부분을 독립적으로 개발하고 테스트할 수 있기 때문이다.

이 아키텍처는 시스템의 유연성과 확장성을 향상시키며, 더 나은 유지보수를 가능하게 하고, 재사용성을 증가시키는 설계 방식이다.

### 플러그인에 대한 논의

ReSharper와 비주얼 스튜디오(Visual Studio)의 관계를 보자.

<p align="center">
<img width="350" alt="image" src="https://github.com/FrontendStudySeoul/cleanArchitecture/assets/70371342/5551324d-a603-4ed0-9275-22deca924e41">
</p>

ReSharper는 비주얼 스튜디오의 확장 프로그램으로, 개발자가 코드를 더 효율적으로 작성하고 관리할 수 있게 돕는 도구이다. ReSharper가 Visual Studio의 소스 코드에 의존하기 때문에 비주얼 스튜디오 팀은 원한다면 언제든지 ReSharper팀을 완전히 무력화할 수 있는 위치에 존재한다.

우리는 시스템에서 한 부분이 변경되더라도 관련 없는 나머지 부분이 망가지길 원치 않기에 시스템을 플러그인 아키텍처로 배치함으로써 변경이 전파될 수 없는 방화벽(경계)을 생성한다.

경계는 변경의 축(axis of change)이 있는 지점에 그어진다. 경계의 한쪽에 위치한 컴포넌트는 경계 반대편의 컴포넌트와는 다른 속도로, 그리고 다른 이유로 변경된다.

업무 규칙은 의존성 주입 프레임워크와는 다른 시점에 그리고 다른 이유로 변경되므로, 둘 사이에도 반드시 경계가 필요하다.

> 시스템의 각 부분은 변경의 이유에 따라 분리되어야 하며, 각각의 컴포넌트나 모듈은 자신의 책임 범위 내에서만 변경되어야 한다. 
단일 책임 원칙을 시사함 → 단일 책임 원칙은 관심사 분리를 위해 어디에 경계를 그어야 할지에 대한 지표가 된다.
> 

### 결론

- 시스템을 **핵심 업무**와 나머지(핵심 업무와 직접적인 관련은 없지만 필수 기능을 포함하는)는 **플러그인**인 컴포넌트 단위로 분리해야 한다.
- 컴포넌트 사이의 화살표는 **저수준 세부사항(플러그인)**에서 **고수준의 안정된 추상화(핵심업무)** 방향을 가리키도록 배치해야한다.

<br/>

## 18장. 경계 해부학

시스템 아키텍처는 일련의 소프트웨어 컴포넌트와 그 컴포넌트들을 분리하는 경계에 의해 정의 된다.

이번 장에서는 경계의 다양한 형태를 알아본다.

### 경계 횡단하기

‘**런타임에 경계를 횡단한다**’함은 시스템의 한 부분이 다른 부분으로 데이터를 전달하거나 기능을 호출할 때, 즉 서로 다른 계층이나 영역, 모듈 간의 상호 작용을 의미한다. (메서드 호출)

- 적절한 위치에서 경계를 횡단하게 하는 비결은 **소스 코드 의존성 관리**에 있다.
    - 소스 코드 모듈이 변경되면 의존되는 다른 소스 코드도 다시 컴파일하고 배포해야 한다. → 시스템 복잡성 증가, 유지보수 어려워짐
- 경계는 이러한 변경이 전파 되는 것을 막는 방화벽을 구축하고 관리하는 수단으로써 존재한다.
    - 시스템의 각 부분은 독립성을 유지해야함.

### 두려운 단일체

> **소스 수준 분리 모드:** 아키텍처 경계 중에서 가장 단순하며 가장 흔한 형태, **물리적으로 엄격하게 구분되지 않는 형태**를 말한다.
> 
- 같은 프로그램 내에서 서로 다른 기능이나 컴포넌트가 나름의 규칙에 따라 코드 수준에서 분리되어 있지만, 모두 동일한 메모리 주소 공간을 공유하고 있는 상태
- 배포 관점에서는 소위 **단일체(monolith)**라고 불리는 단일 실행 파일에 지나지 않는다.
    - 배포 관점에서 볼 때 단일체는 컴포넌트 수준으로 분리되지 않으므로, 배포할 때 개별 컴포넌트를 배포하는 대신 커다란 하나의 파일을 배포하므로 경계가 드러나지 않는다.
- 이러한 아키텍처는 거의 모든 경우에 특정한 동적 다형성에 의존하여 내부 의존성을 관리한다.
    - **동적 다형성** : 실행 시간에 객체의 실제 타입을 결정하여 해당 타입에 맞는 메서드를 호출하는 객체 지향 프로그래밍의 특징. 이는 컴포넌트 간의 결합을 줄이고 확장성을 제공하여 객체 지향 개발이 중요한 패러다임이 될 수 있었다.

> 가장 단순한 형태의 경계 횡단은 **저수준 클라이언트에서 고수준 서비스로 향하는 함수 호출**이다.
> 
- 이 경우 런타임 의존성과 컴파일타임 의존성은 모두 같은 방향, 즉, 저수준 컴포넌트에서 고수준 컴포넌트로 향한다.
- 아래 그림에서 제어흐름은 왼쪽 → 오른쪽, Client는 Service의 함수 f()를 호출하고 이 과정에서 Client는 Data인스턴스를 전달한다. Data는 함수의 인자로 전달할 수도 있고, 더 정교한 다른 기법을 통해 전달할 수도 있다.
    - 클라이언트가 서비스에 의존하는 전통적인 소프트웨어 설계 패턴이고, 클라이언트다 서비스를 이용하기 위해 서비스에 정의된 API를 호출하고, 필요한 데이터를 서비스에 제공한다.
    - 여기서의 경계 횡단이란, 클라이언트가 서비스의 기능을 사용하려고 서비스를 넘어 데이터를 전달하는 프로세스를 말한다.
- 주목할 점은 Data에 대한 정의가 호출되는 Service에 위치한다는 것이다.
    - 이는 서비스가 Data 구조를 알고 있어야 하며, 클라이언트는 이 데이터 구조에 의존하지 않도록 설계되었음을 의미한다.
    - 이 방식은 데이터 구조가 변경될 경우 클라이언트가 영향을 받지 않도록 하며, 서비스의 인터페이스를 통해 클라이언트와 서비스 사이의 결합도를 낮춘다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e2b4061e-f7a4-48fc-84d3-577d21f88cb8/8a469ff0-5c45-4e82-845b-e2005204d51b/Untitled.png)

> 고수준 클라이언트가 저수준 서비스를 호출해야한다면 동적 다형성을 사용하여 제어흐름과는 반대 방향으로 **의존성을 역전**시킬 수 있다.
> 

> 의존성 역전 원칙(DIP; Dependency Inversion Principle) : 고수준 모듈이 저수준 모듈의 구체적인 구현에 직접적으로 의존해서는 안 되며, 대신 양쪽 모두가 추상화에 의존해야 한다.
> 
- 이렇게 하면 런타임 의존성은 컴파일타임 의존성과는 반대가 된다.
- 제어흐름은 이전과 마찬가지로 왼쪽에서 오른쪽으로 경계를 횡단한다. 고수준 Client는 Service인터페이스를 통해 저수준인 Service Impl의 함수 f()를 호출한다.
    - Client는 Services Impl의 구체적인 구현 세부 사항을 알 필요 없이 기능을 사용할 수 있다.
    - 제어 흐름은 Client에서 Service를 거쳐 Service Impl로 이어지지만, 의존성은 Service Impl에서 Service 인터페이스로 향하게 된다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e2b4061e-f7a4-48fc-84d3-577d21f88cb8/4a4de0b9-660d-4707-a1ae-e85209f14dcb/Untitled.png)

정적 링크된 모노리틱 구조의 실행 파일이라도 이처럼 규칙적인 방식으로 구조를 분리하면 프로젝트를 개발, 테스트, 배포하는 작업에 큰 도움이 된다.

팀들은 서로의 영역에 침범하지 않은 채 자신만의 컴포넌트를 독립적으로 작업할 수 있다. 고수준 컴포넌트는 저수준 세부사항으로부터 독립적으로 유지된다.

### 배포형 컴포넌트

- 소프트웨어 아키텍처 내에서 별도로 분리되어 배포될 수 있는 코드의 묶음을 말한다.
    - .NET의 동적 링크 라이브러리DLL, 자바 jar파일 등이 그 예이다.
    - .NET의 동적 링크 라이브러리DLL : 동적으로 로드되거나 다른 애플리케이션에 의해 공유될 수 있는 코드와 데이터를 포함하는 Windows의 파일 형식
    - 자바 jar파일  : 여러 개의 자바 클래스 파일과 관련 메타데이터 및 리소스(텍스트, 이미지 등)를 하나의 압축된 파일로 묶어 배포하는 데 사용되는 파일
- 아키텍처의 물리적 경계를 형성하고, 코드를 모듈화하여 배포하고 재사용하는 데 유용하다.
- 단일체와 마찬가지로 배포형 컴포넌트의 경계를 가로지르는 통신은 순전히 함수 호출에 지나지 않으므로 매우 값싸다.
    - 한 컴포넌트에서 다른 컴포넌트로의 통신이 발생할 때, 호출되는 함수는 다른 컴포넌트 내에 있는 코드를 실행하게 되는 방식
- 초기 함수 호출이 시간이 조금 더 소요될 수 있는 것은 동적 링크와 런타임 로딩 때문이다.
    - 이는 실행 파일이 라이브러리의 코드를 메모리로 로드하고, 필요한 링크를 설정하는 과정에서 발생하는 지연이다.
    - 일단 이 링크가 설정되고 난 후에는 해당 함수 호출은 상대적으로 빠르게 이루어진다.

### 스레드

- 단일체와 배포형 컴포넌트는 모두 스레드를 활용할 수 있다.
    - 모놀리식 아키텍처나 배포형 컴포넌트 아키텍처 모두 멀티스레딩을 지원한다.
- 스레드는 아키텍처 경계도 아니며 배포 단위도 아니다.
    - 애플리케이션의 실행 계획 및 실행 순서를 관리하는 데 사용된다.
    - 동시성과 병렬성을 제공하여 효율적인 실행을 가능하게 한다.
- 모든 스레드가 단 하나의 컴포넌트에 포함될 수도 있고, 많은 컴포넌트에 걸쳐 분산될 수도 있다.
    - 한 서비스의 다양한 요청을 동시에 처리하기 위해 멀티스레딩을 사용할 수 있으며, 이 서비스가 단일 애플리케이션 내에 있거나 여러 독립적인 서비스로 분산되어 있을 수 있다.
    

### 로컬 프로세스

- 물리적 형태를 띠는 아키텍처 경계로는 로컬 프로세스가 있다. 로컬 프로세스는 주로 명령행이나 그와 유사한 시스템 호출을 통해 생성 된다.
- 로컬 프로세스틑 운영 체제의 프로세스 경계를 활용한다. 프로세스틑 독립적인 실행 환경을 제공하고, 명령행 호출이나 시스템 호출을 통해 생성된다.
- 프로세스틑 모노리틱한 단일 실행 파일이거나 여러 동적 링크 라이브러리 등의 결합으로 구성될 수 있다.
- 로컬 프로세스를 일정의 최상위 컴포넌트라고 생각하자. 즉, 로컬 프로세스는 컴포넌트 간 의존성을 동적 다형성을 통해 관리하는 저수준 컴포넌트로 구성된다.
- 로컬 프로세스 간 분리 전략은 단일체나 바이너리 컴포넌트의 경우와 동일하다. 소스 코드 의존성의 화살표는 단일체나 바이너리 컴포넌트와 동일한 방향으로 경계를 횡단한다. 즉, **항상 고수준 컴포넌트를 향한다.**

### 서비스

- 물리적인 형태를 띠는 가장 강력한 경계는 바로 서비스다. 서비스는 프로세스로, 일반적으로 명령행 또는 그와 동등한 시스템 호출을 통해 구동된다.
- 서비스 경계를 지나는 통신은 함수 호출에 비해 매우 느리다. 가능하다면 빈번하게 통신하는 일을 피해야 한다. 이 수준의 통신에서는 지연(latency)에 따른 문제를 고수준에서 처리할 수 있어야 한다.
    - 일반적으로 웹 API를 통한 HTTP 호출 등을 사용하며, 이는 프로세스 내부의 함수 호출보다 훨씬 느리다.
- **저수준 서비스는 반드시 고수준 서비스에 플러그인되어야 한다.** 고수준 서비스의 소스 코드에는 저수준 서비스를 특정 짓는 어떤 물리적인 정보(예를 들면 URI)도 포함해서는 안된다.

### 결론

현대의 시스템 아키텍처는 이러한 다양한 경계를 조합하여 사용한다. 예를 들어, 웹 서비스는 그 자체로 독립된 프로세스일 수 있으며, 내부적으로는 동적으로 로드되는 컴포넌트를 사용하여 더 많은 기능을 제공할 수 있다. 로컬 경계(함수 호출, 로컬 프로세스)와 서비스 경계(네트워크 호출) 사이의 통신 비용과 특성은 서로 매우 다르므로, 각각에 맞는 설계 전략을 적용해야 한다. 이렇게 함으로써, 시스템은 효율적이면서도 유연하게 확장할 수 있는 능력을 갖추게 된다.