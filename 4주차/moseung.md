# 아키텍처 (16장 독립성)
좋은 아키텍처는 다음을 지원해야한다.
<br>
- 시스템의 유스케이스
- 시스템의 운영
- 시스템의 개발
- 시스템의 배포

### 유스케이스
좋은 아키텍처는 유스케이스만 보더라도 어떤 도메인인지 유추하기 쉽다.

### 운영
만약 여러 서비스들을 운영해야할 때 다중 프로세스, 다중 스레드, 또는 마이크로서비스 형태가 필요해질때 계산하기 어렵다.<br>
그러므로 아키텍처에서 각 컴포넌트를 적절히 분리하여 추후 기능의 확장에 유리하도록 운영해야한다.

### 개발
많은 팀을 분리하여도 옳은 개발 프로세스를 가지기 위해서 아키텍처가 중요하다. 콘웨이의 법칙이 적용되는 부분이 여기다.
#### 콘웨이의 법칙
``조직은 조직 내의 의사소통 패턴과 유사한 형태의 시스템을 설계하게 된다.``

### 배포
아키텍처는 배포 용이성을 결정하는 데 중요한 역할을 한다. 좋은 아키텍처는 수십 개의 작은 설정 스크립트나 속성 파일을 약간씩 수정하는 걸 원하지 않는다.

## 유스케이스 결합 분리
결합을 분리하려면 유스케이스를 분리해야한다. 가령 게시판을 CRUD하는 페이지가 있다고 했을때 각각의 유스케이스별로 분리하는것이다.
각각의 유스케이스는 프론트엔드와 백엔드 간의 횡단관심사를 분리할 수 있다. 즉, 프론트엔드는 사용자 인터페이스와 상호작용하는 부분을 담당하고, 백엔드는 데이터 처리와 비즈니스 로직을 담당한다. 
#### 횡단 관심사
<img width="835" alt="image" src="https://github.com/FrontendStudySeoul/cleanArchitecture/assets/103626175/7738d98a-8b69-459c-bdb6-33868a07634a">

## 결합 분리 모드
결합을 분리하면서 얻는 이점은 유스케이스를 처리량으로 구분하여 분리할 수 있다.
<br>
높은 처리량을 요구하는 유스케이스는 서버를 복제하여 해결할 수 있다.
<br>
옛날에는 높은 처리량을 요구하는 유스케이스를 해결하기위해 여러 서버를 띄워서 배포했다.(특히 게임 서비스)
<br>
요즈음엔 클라우드를 이용해서 배포할 경우 오토스케일링이나 로드밸런서를 이용하여서 해결이 가능하다.
<br>
### 프론트엔드에서 결합 분리
프론트엔드에서는 어떤 경우를 유스케이스로 나눌 수 있을까? <br>
아마 제일 대표적인것이 CDN이라고 생각한다. 많은 유저들이 html, css, js, 정적자원(image,video 등)을 서버에 매번 접근하게 된다면 이는 부하와 함께 유스케이스를 잘 나누지 못한 예시가 될것이다.(비용도 더 들것임)
<br>
``여러 나라에 제공한다``를 하나의 유스케이스라고 봤을때도 역시 CDN은 좋은 성능과 함께 관심사를 분리해줄것이다.<br>
또한 프론트엔드에서 이미지를 최적화하는 방법도 여러 방법이 있을텐데 이 또한 적절한 수준에서 회사에 맞는 분리를 실현하여 적용할 수 있다.
<br>
NextJS를 사용하면 소스코드에서 분리, ServerLess한 환경에서 사용하면 배포 수준에서 분리, 직접 최적화한다면 그 이상에서의 분리모드가 될 것이다.<br>

이렇게 결합을 분리하여 개발 생산성을 늘리기 위한 즉 **개발 독립성**을 증가시키고, 이것이 요즘 유행하는 ``마이크로서비스 아키텍쳐``인것 같다. 이러면 각 유스케이스들은 서로에 대한 간섭을 하기 어렵다.
<br>
서로간의 결합이 줄어드니 **배포 독립성**도 증가하게 된다.
#### 마이크로 서비스 아키텍쳐(MSA)
마이크로서비스는 소프트웨어가 잘 정의된 API를 통해 통신하는 소규모의 독립적인 서비스로 구성되어 있는 경우의 소프트웨어 개발을 위한 아키텍처 및 조직적 접근 방식입니다. 이러한 서비스는 독립적인 소규모 팀에서 보유합니다.
<br>
마이크로서비스 아키텍처는 애플리케이션의 확장을 용이하게 하고 개발 속도를 앞당겨 혁신을 실현하고 새로운 기능의 출시 시간을 단축할 수 있게 해 줍니다.

## 결합 분리 모드(디테일)
### 소스코드 수준에서의 분리
- 흔히 쓰이며 소스코드에서 의존성을 서로 분리하여 각각의 컴포넌트로 발전될 수 있도록 한다.
### 배포 수준에서의 분리
- 여러 서비스에서 사용되는 공유 라이브러리의 버전을 배포에서 따로 분리하여 이부분을 하나의 독립적으로 운영한다. 이를 캐싱하면 더 좋은 성능을 이끌어낼 수 있다.
### 서비스 수준에서의 분리
- 의존하는 수준을 데이터 구조까지 낮출 수 있다.
- 순전히 네트워크 패킷을 통해서만 통신하도록 만들 수 있다.
- 모든 실행 가능한 단위는 소스와 바이너리 변경에 대해 서로 완전히 독립적이게 된다.

### 사용하기에 가장 좋은 모드
결국 처음에는 어떤 모드가 최적인지 알 수 없다. 그래서 프로젝트가 성숙할수록 어떤 모드가 최적인지 알 수 있다.
<br>
서비스수준으로 나눠야하는 모드가 좋아지다가도 추후에는 소스코드 수준에서 나눠야하는 모드가 최적일 수 있기에 아키텍처는 언제든 상황을 돌릴 수 있도록 모놀리틱하게 운영되어야 한다.

## 결론
- 시스템의 결한 분리 모드는 시간이 지나면서 바뀌기 쉽다.
- 뛰어난 아키텍트라면 이러한 변경을 예측하여 큰 무리 없이 반영할 수 있도록 만들어야 한다.


### Amazon EC2 Spot Instances
Spot Instances는 AWS의 남는 컴퓨팅 자원을 사용하여 저렴한 비용으로 EC2 인스턴스를 실행할 수 있는 옵션입니다.<br>
Spot 인스턴스는 일반적으로 예비 용량으로 사용되는 자원을 사용하므로 온디맨드 인스턴스에 비해 저렴하게 이용할 수 있습니다.<br>
그러나 Spot 인스턴스는 가격이 변동할 수 있으며, AWS에서 필요한 용량을 요구할 때 인스턴스가 종료될 수 있습니다.

1. Auto Scaling 그룹을 설정하고 EC2 Spot Instances를 대상으로 지정합니다.
2. Auto Scaling 그룹의 원하는 최소 및 최대 인스턴스 수를 설정하여 필요한 최소한의 용량을 보장합니다.
3. Spot 인스턴스가 사용 불가능할 때를 대비하여 On-Demand 인스턴스 또는 예약 인스턴스를 포함하여 Auto Scaling 그룹에 다양한 인스턴스 유형을 지정합니다.

### ECR(Elastic Container Registry)
현재 회사 내에서 ECR을 이용하여 이미지들을 관리하고 이를 이용하여 서버를 관리하고 있다.
이를 사용하면 크게 4가지 장점이 있다.
1. 중앙화
2. 재사용
3. 버전관리
4. 보안
<br>
회사 내 NextJS서비스들은 매 빌드마다 변경점을 통해 이미지를 빌드하고 재사용되는 부분은 캐싱하여 성능을 향상하며, 만약 배포에 문제가 있을때는 직전 이미지로 돌려 배포를 돌릴 수 있다.(버전관리)
<br>
그리고 만약 여러 서비스에서 같은 스택을 사용한다면 이미지를 재사용할 수 있다(재사용)
<br>
그리고 모든 이미지들을 한곳에서 관리하여 중앙화를 할 수 있다.



