## 15장. 아키텍처란?

> 아키텍처란 **시스템을 구축했던 사람들이 만들어낸 시스템의 형태**이다. 시스템을 컴포넌트로 분할하고, 배치하고, 의사소통하는 방법에 따라 정해진다.
> 그리고 그 형태는 아키텍처 안에 담긴 소프트웨어 시스템이 쉽게 개발, 배포, 운영, 유지보수되도록 만들어진다.
>

- 아키텍처의 주된 문적은 시스템의 생명주기를 지원하는 것.
- 좋은 아키텍처는 시스템을 쉽게 이해하고, 쉽게 개발하며, 쉽게 유지보수하고, 쉽게 배포하도록 해준다.
- 아키텍처의 궁극적 목표 : 시스템 수명 관련 비용 최소화, 프로그래머의 생산성은 최대화

### **개발**

시스템 아키텍처는 개발팀이 시스템을 쉽게 개발할 수 있도록 뒷받침해야한다. 팀 구조가 다르면 아키텍처 관련 결정에서 차이가 난다.
<img width="901" alt="image" src="https://github.com/FrontendStudySeoul/cleanArchitecture/assets/70371342/f345b28b-e57a-4330-a053-672de84f1a18">

- 5명으로 이루어진팀에서는 모놀리틱한 시스템을 개발할 수 있다. 아키텍처 관련 제약들이 오히려 방해가 된다고 여길 가능성이 높다.
    - monolithic : 단일 코드 트리 구조의 프로그램, 컴포넌트 단위로 구분되지 않고 여러 기능이 하나로 결합된 형태를 띈다. 통짜 프로그램
- 7명씩 이루어진 5개의 팀에서는 시스템을 신뢰할 수 있고 안정된 인터페이스를 갖춘, 잘 설계된 컴포넌트 단위로 분리하지 않으면 개발이 진척되지 않는다.
    - 다른 요소를 고려하지 않는다면, 이 시스템의 아키텍처는 각 팀 마다 하나씩 발전 될 가능성이 높다. 팀별 단일 컴포넌트 아키텍처가 시스템을 배포, 운영, 유지보수하는 데 최적일 가능성은 거의 없다.

### **배포**

> 소프트웨어 시스템이 사용될 수 있으려면 반드시 배포할 수 있어야 한다. 소프트웨어 아키텍처는 시스템을 한 번에 쉽게 배포할 수 있도록 만드는데 그목표를 두어야한다.
> 
- 초기 개발 단계에서는 배포 전략을 거의 고려하지 않는다. 개발자는 개발은 쉬울지 몰라도 배포하기 어려운 아키텍처가 만들어진다.
    - 마이크로서비스 아키텍처를 사용하면 컴포넌트 경계가 뚜렷해지고 인터페이스가 대체로 안정화된다 생각해 개발을 매우 쉽게 할 수 있겠지만, 배포 시기에 방대한 마이크로서비스로 인해 문제가 발생할 수 있다. → 마이크로서비스들을 서로 연결하기 위해 설정하고 작동 순서를 결정하는 과정에서 오작동이 발생할 원천이 스며들 수도 있다.
    - 만약 아키텍트가 초기에 배포를 고려했다면, 더 적은 서비스에서 컴포넌트와 프로세스 수준의 컴포넌트를 하이브리드 형태로 융합하며 좀 더 통합된 도구를 사용하여 상호 연결을 관리했을 것이다.
<img width="1089" alt="image" src="https://github.com/FrontendStudySeoul/cleanArchitecture/assets/70371342/75cc1a2f-b306-4da6-8608-652a060e3b7d">

<img width="922" alt="image" src="https://github.com/FrontendStudySeoul/cleanArchitecture/assets/70371342/01991e8f-274b-45f2-98e9-b5b253bddaa4">

### **운영**

> 운영을 방해하는 아키텍처가 개발, 배포, 유지보수를 방해하는 아키텍처보다는 비용이 덜 든다.
> 
- 운영은 더 좋은 하드웨어로 어느 정도 타협 가능하다. 단순히 스토리지와 서버를 추가하는 것만으로 제대로 동작하도록 만들 수 있을 때가 많다.
- 하지만, 좋은 소프트웨어 아키텍쳐는 시스템을 운영하는데 필요한 요구도 알려준다.
    - 시스템 아키텍처가 개발자에게 시스템의 운영 방식을 잘 드러내 준다고 할 수 있다.
    - 시스템 아키텍처는 유스케이스, 기능, 시스템의 필수 행위를 일급 엔티티로 격상시키고 이들 요소가 개발자에게 주요 목표로 인식되도록 해야한다. 이를 통해 시스템을 이해하기 쉬워지며, 개발과 유지보수에 도움이 된다.
  > ex) 온라인 쇼핑몰
  > - 이 사이트의 주요 유스케이스는 물건을 검색하고, 장바구니에 추가하며, 결제하는 과정
  > - 이 경우, 검색, 장바구니 관리, 결제 처리 등의 기능을 시스템의 '일급 엔티티'로 취급해야 한다.
  > - 즉, 이 기능들은 웹사이트 설계와 개발에서 중심적인 역할을 해야 하며, 이를 기반으로 전체 시스템의 구조와 코드가 구성되어야 한다.
  > - 따라서, 이러한 유스케이스와 필수 행위들이 시스템 아키텍처에서 중심적인 역할을 하게 함으로써, 개발자들은 시스템의 주요 목적과 기능을 더 잘 이해하고, 사용자에게 중요한 기능에 더 집중할 수 있게 된다.

### **유지보수**

> 유지보수는 소프트웨어 시스템에서 비용이 가장 많이 든다.
> 
- 유지보수의 가장 큰 비용은 탐사와 이로 인한 위험 부담에 있다.
    - 탐사 : 기존 소프트웨어에 새로운 기능을 추가하거나 결함을 수정할 때, 소프트웨어를 파헤쳐서 어디를 고치는 게 최선인지 결정할 때 드는 비용.
    - 변경사항을 반영할 때 의도치 않은 결함이 발생할 가능성은 항상 존재하며, 이로 인한 위험부담 비용이 추가된다.
- 주위를 기울여 신중하게 아키텍처를 만들면, 이 비용을 크게 줄일 수 있다.
    - 시스템을 컴포넌트로 분리하고 안정된 인터페이스로 두어 서로 격리하는 방식.
    

### **선택사항 열어 두기**

> 소프트웨어는 기계의 행위를 빠르고 쉽게 변경할 수 있을 구조적 가치가 중요하다. 이런 유연성은 시스템의 형태, 컴포넌트 배치방식, 컴포넌트 상호 연결 방식에 크게 의존한다. 소프트웨어를 부드럽게 유지하는 방법은 선택사항을 가능한 한 많이, 그리고 가능한 오랫동안 열어 두는 것이다.
> 
- 열어 두어야 할 선택사항은 중요하지 않은 세부 사항을 의미한다.
- 모든 소프트웨어 시스템은 주요한 두 가지 구성요소인 정책(Polciy)과 세부사항(Detail)으로 분해할 수 있다.
    - 정책 요소는 모든 업무 규칙(Business Rules)과 업무 절차(Procuedures)를 구체화 한다. 시스템의 진정한 가치가 살아있는 곳이다.
    - 세부사항은 사람, 외부 시스템, 플그래머가 정책과 소통할 대 필요한 요소지만, 정책이 가진 행위에는 조금도 영향을 미치지 않는다.
        - 이러한 세부 사항에는 입출력 장치, 데이터 베이스, 웹 시스템, 서버, 프레임워크, 통신 프로토콜 등이 있다.
    - 아키텍트의 목표는 시스템에서 정책을 가장 핵심적인 요소로 식별하고, 동시에 세부사항은 정책에 무관하게 만들 수 있는 형태의 시스템을 구축하는데 있다. 이를 통해 세부사항을 결정하는 일은 미루거나 연기할 수 있게 된다.
        - ex. 개발 초기엔 데이터베이스 시스템을 선택할 필요가 없음 → 고수준의 정책을 데이터베이스가 관계형인지, 분산형인지, 계층형인지, 아니면 평범한 플랫파일인지 관련 없도록 만들어야 한다.
        - 고수준의 정책을 세부사항과는 관련이 없도록 만들어야 한다. 세부사항에 몰두하지 않은 채 고수준의 정책을 만들 수 있다면, 세부사항에 대한 결정을 오랫동안 미루거나 연기할 수 있다.
        - 이를 통해 다양한 실험을 시도해 볼 수 있고 많은 것을 시도할 수 있다. 더 이상 연기할 수 없는 순간이 닥쳤을 떄는 이러한 실험과 시도 덕분에 더 많은 정보를 획득한 상태일 것이다.

### 저자의 장치 독립성, 광고 우편, 물리적 주소 할당 예시
- 장치와 직결되는 명령어를 작성 시에는 데이터 무결성이 문제로 대두됨 -> 동일한 프로그램을 아무런 변경 없이도 다른 장치에서도 읽고 쓸 수 있어야 함 -> 개방 폐쇄 원칙이 탄생한 배경
- 어떤 장치를 사용할지 전혀 모르고 고려하지 않고도 프로그램을 작성하게끔 해야함 -> 이 경우 정책은 서식이고 세부사항은 장치가 됨

### **결론**

좋은 아키텍트는 세부사항을 정책으로부터 신중하게 가려내고, 정책이 세부사항과 결합되지 않도록 엄격하게 분리한다. 이를 통해 정책은 세부사항에 관한 어떠한 지식도 갖지 못하게 되며, 어떤 경우에도 세부사항에 의존하지 않게 된다. 세부사항에 대한 결정을 오랫동안 미룰 수 있는 방향으로 정책을 설계한다.
