# 4부. 컴포넌트 원칙

## 12장.  컴포넌트

컴포넌트 : 시스템의 구성 요소로 배포할 수 있는 가장 작은 단위

- 자바  - jar
- 루비 - gem
- 닷넷 - dll
- 컴파일형 언어 - 바이너리 파일의 결합체
- 인터프리터형 언어 - 소스파일의 결합체

여러 컴포넌트를 서로 링크하여 실행 가능한 단일 파일로 생성

여러 컴포넌트를 서로 묶어서 .war  파일과 같은 단일 아카이브로 만들 수도 있다

컴포넌트 각각을 .jar나 dll같이 동적으로 로드할 수 있는 플러그인이나 .exe 파일로 만들어서 독립적으로 배포 가능

### 컴포넌트의 간략한 역사

- 개발 초창기
    - 프로그램이 로드될 주소(오리진, Origin)를 프로그래머가 직접 제어
    - 한번 메모리 위치가 결정되면 재배치가 불가능
    - 라이브러리 함수에 접근하려면 애플리케이션 코드에 직접 포함을 시켜 단일 프로그램을 컴파일
    - 컴파일 과정이 너무 오래걸리고, 메모리는 너무 비쌈
- 문제점 해결
    - 컴파일 시간을 단축시키기 위해 라이브러리 소스코드를 애플리케이션 코드와 분리
    - 함수 라이브러리를 개별적으로 컴파일
    - 컴파일된 바이너리를 메모리의 특정 위치에 로드
    - 실행 시 라이브러리를 로드한 후 애플리케이션을 로드

### 재배치성

재배치가 가능한 바이너리를 통해 Loader를 사용해서, 메모리에 재배치 할 수 있는 형태의 바이너리를 생성하도록 컴파일러를 수정하는 방법

- 프로그램이 라이브러리 함수를 호출한다면 컴파일러는 라이브러리 함수 이름을 외부 참조(external reference)로 생성
- 반면 라이브러리 함수를 정의하는 프로그램이라면 컴파일러는 해당 이름을 외부 정의(external definition)로 생성
- 이렇게 함으로써 외부 정의를 로드할 위치가 정해지기만 하면 로더가 외부 참조를 외부 정의에 링크시킴
- 이렇게 링킹 로더(linking loader)가  탄생

### 링커

링킹  로더의 탄생으로 프로그램을  개별적으로 컴파일하고 로드할 수 있는 단위로 분할할 수 있게 되었다.

- 1960s 속도의 문제로 로드와 링크를 분리했다. 프로그래머는 링커라는 애플리케이션으로 링크 과정을 맡았다. 링커로 링크가 완료된 재배치 코드를 만들었고, 따라서 로더의 로딩 과정이 아주 빨라졌다.
- 1980s 무어가 나타나며, 컴퓨터는 빨라지고 저렴해졌다.
- 현재 컴퓨터와 장치가 빨라져 로드와 링크를 동시에 가능하게 되었다.

이렇게 컴포넌트 플러그인 아키텍처가 탄생했다.

### 요약

- 잘 설계된 컴포넌트라면 반드시 독립적으로 배포 가능한, 따라서 독립적으로 개발 가능한 능력을 갖춰야 한다.
- 옛날부터 여러 노력을 통해 컴퓨터 성능을 높였고, 지금은 그러한 노력들로 인해 컴포넌트 플러그인 아키텍처를 쉽게 사용가능하다.
- 런타임에  플러그인 형태로 결합할 수 있는 동적 링크 파일이 이  책에서 말하는 소프트웨어 컴포넌트에 해당한다.
