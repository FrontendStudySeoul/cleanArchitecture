# Clean Architecture

> 아키텍처는 시스템을 구체화하는 중요한 설계 결정을 표현하며, 그 결정의 중요도는 변경에 드는 비용으로 측정된다. - 그래디 부치(Grady Booch)
> 

> 아키텍처는 구현과 측정을 통해 증명해야 하는 가설이다. - 톰 길브(Tom Gilb)
> 

> 빨리 가는 유일한 방법은 제대로 가는 것이다. - 로버트 C. 마틴(Robert C. Martin)
> 

- 수 많은 앱과 서비스 사이를 관통하는 아키텍처 규칙은 동일하다.
    - 반세기 동안 하드웨어의 성능이 발전하는 중에도 코드는 크게 변하지 않았다.
    - 반세기 동안 이어져 온 이 소프트웨어 규칙을 어겨왔고, 이를 증명해 옴
    - 이 책은 세월이 지나도 변치 않는 규칙에 대한 책
 


# 1부. 소개

## 1장. 설계와 아키텍처란?

- 소프트웨어 아키텍처(SA)의 목표
    - 필요한 시스템을 만들고 유지보수 하는 데 투입되는 인력을 최소화
    - 새로운 기능을 출시할 때마다 비용이 증가한다면 나쁜 설계
    - 비용은 최소화하고, 생산성을 최대화 하는 SA의 속성
        
        ⇒ 이 책에서 다룰 내용
        

## 2장. 두 가지 가치에 대한 이야기

- 소프트웨어 시스템은 이해관계자에게 서로 다른 두 가치를 제공
    - 행위(behavior)
    - 구조(structure)
- 소프트웨어 개발자는 두 가치를 모두 반드시 높게 유지해야 하는 책임을 가짐

### 행위(behavior)

- 디버거로 문제 고치기
- 요구사항을 구현하고 버그를 수정하는 일 ⇒ 우리는 그 이상을 해야 한다.

### 아키텍처

- 소프트웨어를 만든 이유
    - 기계의 행위를 쉽게 변경할 수 있도록 하기 위하여
    - ”soft” + “ware”
- 변경사항을 적용하는 데 드는 어려움
    - 범위(scope)에 비례
    - 형태(shape)와 관련 없음
- 아키텍처는 형태에 독립적이어야 하고, 그럴수록 실용적이다.

### 아이젠하워 매트릭스

1. 긴급하고 중요한
2. 긴급하지는 않지만 중요한
3. 긴급하지만 중요하지 않은
4. 긴급하지도 중요하지도 않은

⇒ 기능의 긴급성이 아닌 아키텍처의 중요성을 설득하는 일은 SW 개발팀이 마땅히 책임져야 할 일




# 2부. 벽돌부터 시작하기: 프로그래밍 패러다임

- 패러다임
    - 프로그래밍을 하는 방법
    - 대체로 언어에는 독립적

## 3장. 패러다임 개요

- 구조적 프로그래밍
    - 제어흐름의 직접적인 전환에 대해 규칙을 부과
- 객체 지향 프로그래밍
    - 제어흐름의 간접적인 전환에 대해 규칙을 부과
- 함수형 프로그래밍
    - 변수 할당문에 대해 규칙을 부과

### 생각할 거리

- 패러다임은 프로그래머에게서 권한을 박탈한다. 즉, 추가적인 규칙을 부과한다.
- 무엇을 해야 할지 < 무엇을 해서는 안 되는지
- 세 가지 패러다임과 아키텍처의 세 가지 큰 관심사(함수, 컴포넌트 분리, 데이터 관리)의 연관성 주목해보기

## 4장. 구조적 프로그래밍

- 구조적 프로그래밍이 가치있는 이유
    - 프로그래밍에서 반증 가능한 단위를 만들어 낼 수 있다는 것
    - 기능적 분해
- 아키텍트는 모듈, 컴포넌트, 서비스가 쉽게 반증 가능하도록(테스트하기 쉽도록) 만들기 위해 노력해야 한다.

## 5장. 객체 지향 프로그래밍

- Object-Oriented (OO)
    - 다형성을 이용하여 전체 시스템의 모든 소스 코드 의존성에 대한 절대적인 제어 권한을 획득할 수 있는 능력
    - 플러그인 아키텍처 구성 가능
    - 모듈 간 모듈에 대해 독립성을 보장하여 독립적으로 개발하고 배포 가능

## 6장. 함수형 프로그래밍

- 소프트웨어, 즉 컴퓨터 프로그램은 순차(sequence), 분기(selection), 반복(iteration), 참조(indirecion)로 구성된다. 그 이상도 그 이하도 아니다.

# 요약

- Uncle Bob이 이 책에서 핵심적으로 다루고자 하는 주요 아키텍처를 설명하기 위한 SW 개념과 사례
- 실무에서 경험할 수 있는 딜레마와 소프트웨어 개발자의 역할에 대한 재발견


# Reference

**[The Clean Code Blog by Robert C. Martin (Uncle Bob)](http://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)**

![image](https://github.com/FrontendStudySeoul/cleanArchitecture/assets/25587196/f3ba87b6-a6ff-413d-8dd5-1654fcc9524b)
- 소프트웨어 개발 디자인 패턴 중 하나
- 로버트 C. 마틴이 2012년에 제안한 아키텍처 원칙
- 클린 아키텍처 or 헥사고날 아키텍처 or 포트와 어댑터 패턴이라고도 부름 (책 22장에서 다룰 예정)


**[클린아키텍처 썼는데 왜 프로젝트가 더 더러워지지](https://medium.com/mj-studio/클린아키텍처-썼는데-왜-프로젝트가-더-더러워지지-3565aaffca8c)**
- 다른건 다 포기하서라도 무조건 준수해야 하는 것은 의존성 규칙 (레이어)
- 클린아키텍처를 소개하는 어떤 글들은 너무 과도하게 레이어에 집착하는 경향
- 아키텍처를 구현하기 위한 수단으로 레이어링을 하는것이 아닌 수단을 위한 코드를 짜게될 위험
- 프로젝트가 커감에 있어 아키텍처의 추상적 개념은 유지하되 그 구현법에 있어서는 코드와 다를 것 없이 유연한 리팩터링이 필요

## 생각해보기

- 앱 규모와 변경 가능성에 맞는 기능 중심 설계 vs 소프트웨어 지식 습득에 대한 비용?
