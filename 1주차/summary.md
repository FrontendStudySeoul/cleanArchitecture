## 소프트웨어 아키텍처의 품질
- 소프트웨어 아키텍처의 품질을 고민하지 않으면 추후 생산성에 문제가 생길 수 있음
- 소프트웨어는 부드러움을 유지해야 함
- 아키텍처는 긴급하지만 중요함

## 프로그래밍 패러다임
- 프로그래밍 패러다임은 프로그래머한테 새로운 권한을 주는 게 아니라 규칙만 부과함
- 프로그래밍은 과학이며 수학은 증명 가능한 서술이 참임을 입증하는 원리임
- 과학은 증명한 것이 서술이 거짓임을 입증하는 원리임

## 다양성
- 언어는 캡슐라에서는 0점이고 상속은 한 반 점 정도 줄 수 있다라고 책이 돼 있었음
- 다양성은 하나의 인터페이스나 추상 클래스로 여러 가지 클래스를 구현할 수 있다라는 것임
- 다양성 덕분에 우리는 장치 의존적인 프로그램에서 장치의 독립적인 프로그램을 만들 수 있게 됐고 새로운 요구 사항을 받아들일 수 있게 됨

## 함수형 프로그래밍의 원칙
- 소프트웨어 아키텍처에서는 의존성 정보에 대해서 방향을 결정할 수 있는 절대적인 권한을 갖는 것이 중요함
- 함수형 프로그래밍은 순수 함수 위주로 코딩하는 것으로 함수형 프로그래밍의 원칙은 가변성을 분리하는 것임
- 함수형 프로그래밍은 가변 변수로 인해 발생하는 문제를 해결하기 위해 등장함

## 트랜잭션 메모리의 개념
- 트랜잭션 메모리는 원자성 일관성 격리성 지속성을 토대로 데이터 무결성을 보장하고 동시성을 향상시킴
- 함수형 컴포넌트는 가변 상태가 더욱더 적어짐
- 현대에서는 데이터 저장소의 발전으로 데이터 저장소에서 삭제되거나 변경되는 일이 없음

## 구조적 프로그래밍과 객체 지향 프로그래밍의 차이
- 구조적 프로그래밍은 제어 흐름의 직접적인 권한을 가지고 객체 지향은 다양성 캡슐화 상속 등을 토대로 간접적인 전환에 뷰를 부과하고 함수형 프로그래밍은 변수 할당을 직접 할 수 없도록 귤을 주는 것임
- 객체 지향은 캡슐화와 상속 다양성의 본질을 가지고 있고 구조적 프로그래밍은 순차 분기 반복이라는 세 가지 구조만으로 표현할 수 있음을 증명함
- 테스트는 버그가 있음을 보여줄 뿐이고 버그가 없음을 말해주지 않음

## 불변성과 가변성
- 다양성은 특정 기능을 처음 부분과 구현 부분으로 분리한 후 구현 부분을 다양한 방법으로 만들어 선택해서 사용할 수 있게 하는 기능임
- 의존성 역전은 트리 구조 같았고 프로스 드릴링 하는 약간 그런 느낌이었고 의존성 약정이라는 개념을 생각했을 때 뮤직 콘텍스트나 다른 라이브러리가 생각이 났다는 걸 말씀드리고 싶었음
- 함수형 프로그래밍에서는 일반적으로 자바와 같은 프로그래밍은 같은 변수를 갖고 있는데 함수형 프로그래밍에서는 가격 변수가 없음
- 불변성과 아키텍처에서는 경쟁 건이나 교차 그리고 동시성 문제는 모두 가변 변수로 인해서 발생을 하게 되는데 이러한 발생을 하게 된다라고 말을 하고 있음
- 불변성이 가능하다면 이 부분은 좋겠지만 저장 공간이나 프로세스 속도가 무한하다는 전제가 있어야 되기 때문에 이를 위한 일종의 타협이 필요함
- 가변성 분리라는 개념이 들어오게 됐는데 여기서는 불변성과 관련해 가장 주요한 타협 중 하나는 애플리케이션 또는 거기 내부에 있는 서비스를 가벼운 컴포넌트와 블 컴포넌트로 분류하는 일임

## 아키텍처의 중요성
- 시스템을 구체화하는 중요한 설계 결정을 표현을 하며 결정의 중요도는 변경에 드는 비용으로 측정됨
- 변경에 대한 비용이라는 걸로 아키텍처에 중요도를 증명할 수 있다는 생각이 들면서 어떤 거를 더 중요하게 생각해야 되는지에 대한 선후 관계를 생각하게 됨
- 소프트웨어 아키텍처는 소프트웨어를 만드는 이유, 기계 행위가 단순하게 단순 케이스에 대한 행위만 반복하는 게 아니라 이 행위를 쉽게 변경을 해서 활용할 수 있는 부분이 소프트웨어를 만드는 이유임

## 클린 아키텍처
- 소프트웨어적으로 생각을 해야 되는 부분들 키워드 개념과 사례를 제시한다는 생각이 들었고 실무에서 경험을 할 수 있는 딜레마적인 케이스들 그리고 개발을 하면서 어떤 역할을 하고 고민을 해봐야 되는지에 대해서 한 번 더 고민을 해봤던 것 같음
- 클린 아키텍처를 소개를 하고 정답이야라고 하는 부분들이 너무 과도하게 계층을 나누고 그러는 것이 더 효용성이 있다고 하는 게 좀 너무 좀 과도하지 않냐라는 의견임

## 마이크로 프론트엔드의 한계
- 마이크로 프론트엔드는 아키텍처 관점이어서 아키텍처를 미리 짠 사람이 있고 실제로 기능 구현을 하는 사람이 있는데 이해도의 격차가 있으면 와닿지가 않는 부분들이 많음
- 마이크로 프론트엔드는 아키텍처를 미리 짠 사람이 있고 실제로 기능 구현을 하는 사람이 있는데 사실 이 이해도의 격차가 있으면 좀 와닿지가 않는 부분들이 되게 많아서 왜 이걸 굳이 이렇게 나눠서 하지 이걸 왜 이걸 레이어를 나눠서 하지에 대한 합의가 잘 되지 않는 부분이 있었음

## 커뮤니케이션 비용을 줄이는 방법
- 일상에서 제일 인상 깊었던 게 빨리 가는 유일한 방법은 제대로 가는 것이다임
- 커뮤니케이션 비용이 더 많이 들고 안 좋아진다고 생각이 들었었음
- 코드를 같이 협업하는 다른 분이 제 코드를 봤을 때 항상 저한테 이거 왜 이렇게 짜신 거예요? 이렇게 물어보셨음
- 커뮤니케이션 비용도 되게 많이 줄었던 경험이 있었음

## 아키텍처의 중요성
- 긴급하지만 중요하지 않은 기능이나 이슈들이 첫 번째로 챙겨가야 된다고 실수를 함
- 이슈가 올라왔을 때 급한 건가요 중요도는 어떻게 되나요라고 항상 물어보는 게 습관처럼 됐음
- 개발자는 무조건 아키텍처를 위해서 투쟁을 해야 된다고 함

## 함수형 프로그래밍의 개념
- 구조적 프로그래밍 개최 지향 프로그램 함수형 프로그래밍에 대해서 개념적으로만 들었음
- 패러다임이라는 게 무엇을 해서는 안 되는지 말해주는 것임
- 객체 지향 프로그램에서는 유전성 약점과 다양성 얘기하고 있는데 리액트에서 프로스 딥 트릴링을 방지하기 위해서 컨테스트 API를 사용해서 유동성 주입을 시켜서 추상화 계층을 만들어서 저소득 모듈에서 고소득 모듈에 도달할 수 있게끔 하는 메커니즘이 생각이 났었음
- 함수형 프로그래밍에서는 현명한 아키텍처라면 가능한 많은 부분을 불변 컴포넌트로 분리하고 가변 컴포넌트는 최소한으로 줄여야 됨

## 구조적 프로그래밍
- 1장에서는 설계랑 아키텍처 다 설명해 주신 내용을 있는데 토끼랑 거북이 예시를 들자면요. 저도 이 부분 되게 공감하면서 읽었던 것 같음
- 과정에서 이제 개발적인 코드 구조를 잘 짜는 거를 구조라고 이해를 했음
- 다 설명해 주신 것처럼 반드시 부드러워야 하고 변경하기 쉬워야 함
- 소프트웨어 같이 이것도 나왔는데 다 얘기하 이것도 넘어가겠음
- 패러다임에 대해서 조금 좀 재미있게 읽었는데 책이 조금 불친절하다고 생각했음
- 구조적 프로그래밍 이런 거 나오는데 예시도 거의 없고 그래서 좀 예시 위주로 저는 정리를 해봤음

## 객체 지향화의 장점
- 객체 지향화는 다양성을 통해서 다른 장치에서도 동일하게 동작할 수 있는 독립성을 이뤘다는 점에서 강력한 점을 다양성이라고 찍는 것 같음
- 의존성 역장은 코드 의존성이 재 흐름과는 반대되는 거를 의존성 역점이라고 함
- 의존성이 역전 원칙이라는 원칙을 따라서 개발을 함

## 아키텍처의 중요성
- 소프트웨어 시스템이 무엇인지 인지를 하고 있는지를 통해서 얻고자 하는 게 뭔지 설계를 통해서 아키텍처는 소프트웨어 시스템을 할 때 왜 중요한지 중요하다면 어떻게 해야지 잘 만들 수 있는지에 대해서 미리 생각을 하고 과연 개발을 하고 있는가에 대해서 스스로 자문을 하게 만드는 네 가지 질문이 있었음
- 설계란 개별로 전쟁을 할 수 없고 경기도 뚜렷하지 않은데에 대해서 좋은 설계란 무엇인지 나쁜 설계란 무엇인지에 대해서 좀 더 생각을 해보고 싶었고 거기에 관련해서도 좀 얘기를 많이 나눴던 것 같음
- 코드에 대해서 너무 작성하다 보면 결국 자기 코드를 너무 믿는 경향이 있는데 가능하면 좀 배제를 하고 나중에 개선하겠다라는 자기 확신을 좀 배제를 해야 되겠다라는 생각을 했음

