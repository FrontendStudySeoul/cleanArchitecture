# CH 01. 소개
## 1장. 설계와 아키텍처란?

> 소프트웨어 아키텍처의 목표는 필요한 시스템을 만들고 유지보수하는 데 투입되는 인력을 최소화하는 데 있다.

1장은 클린코드를 작성해야 하는 이유에 대해 여러차례 설명하고 있다. 
토끼와 거북이의 예시를 들며 자신의 빠르기를 과신한 토끼처럼 새로운 기능 개발만을 좇게되면, 코드의 생산성은 계속 낮아지고 결국 지저분한 코드를 작성하게 될 것이라고 얘기한다.

> 빨리 가는 유일한 방법은 제대로 가는 것이다.


## 2장. 두 가지 가치에 대한 이야기
이 장에서는 "행위(behavior)"와 "구조(structure)"라는 두 가지 가치에 대해 설명한다.

**행위**는 일반적으로 기획자와 커뮤니케이션을 통해 요구사항 문서를 구체화하고, 이를 코드로 작성해 개발하는 일련의 과정을 의미한다.

> 소프트웨어의 첫 번째 가치는 바로 **행위**다. 
> 프로그래머는 이해관계자가 기능 명세서나 요구사항 문서를 구체화할 수 있도록 돕는다. 그리고 기계가 이러한 요구사항을 만족하도록 코드를 작성한다.

구조는 그런 코드를 작성할 때의 아키텍처를 의미한다.
이 구조는 새로운 요구사항이 들어와도 쉽게 개발할 수 있게 만드는 것이 중요하다.

> 소프트웨어가 가진 본연의 목적을 추구하려면 소프트웨어는 반드시 '부드러워'야 한다. 다시 말해 변경하기 쉬워야한다.

책에서 소프트웨어의 가치 우선순위를 다음과 같이 설명한다.
1. 긴급하고 중요한
2. 긴급하지는 않지만 중요한
3. 긴급하지만 중요하지 않은
4. 긴급하지도 중요하지도 않은



# CH02. 벽돌부터 시작하기: 프로그래밍 패러다임
## 패러다임 개요
> 패러다임은 무엇을 해야 할지를 말하기보다는 무엇을 해서는 안 되는지를 말해준다.
> 세 가지 패러다임 각각은 우리에게서 goto문, 함수 포인터, 할당문을 앗아간다.

## 구조적 프로그래밍 (=절차적 프로그래밍)
> 모든 프로그램을 **순차, 분기, 반복**이라는 세 가지 구조만으로 표현할 수 있다는 사실을 증명했다.

> 구조적 프로그래밍을 통해 모듈을 증명 가능한 더 작은 단위로 재귀적으로 분해할 수 있게 되었고, 이는 결국 모듈을 기능적으로 분해할 수 있음을 뜻했다.

> 구조적 프로그래밍은 프로그램을 증명 가능한 세부 기능 집합으로 재귀적으로 분해할 것을 강요한다. 그리고 나서 테스트를 통해 증명 가능한 세부 기능들이 거짓인지를 증명하려고 시도한다.

구조적 프로그래밍은 프로그래밍의 흐름이 순차적으로 이루어지고, 순차 / 분기 / 반복의 논리 구조만으로 이루어진 것을 의미한다. 대표적으로 C 언어가 있다.

```c
main(){
	int a;
	a = 5;

	printf("a = ", a);
}
```


## 객체지향 프로그래밍
객체 지향(OO)의 본질을 3개로 설명한다.
1. 캡슐화
2. 상속
3. 다형성

객체 지향 개념의 가장 기본적인 전제는 실제 세계는 객체들로 구성되어 있으며, 보여지는 모든 현상과 발생하는 모든 사건은 이러한 **객체들 간의 상호작용**을 통해 발생한다는 것에서 출발한다.
이런 객체를 만들어 유기적인 상호작용을 규정해 프로그램을 발전시키는 프로그래밍 방법론을 "객체지향 프로그래밍"이라 한다.
[출처](https://www.codestates.com/blog/content/%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%ED%8A%B9%EC%A7%95)



### 1. 캡슐화
> 캡슐화를 통해 데이터와 함수가 응집력 있게 구성된 집단을 서로 구분 짓는 선을 그을 수 있다.

> OO를 제공한다고 주창한 언어들이 실제로는 C 언어에서 누렸던 완벽한 캡슐화를 약화시켜 온 것은 틀림없다.

켑슐화는 서로 연관있는 속성, 기능들을 하나의 캡슐로 만들어 데이터를 외부로 부터 보호하는 것을 의미한다. 
캡슐화를 통해 필요한 부분만 외부에 노출될 수 있도록 해 각 객체 고유의 독립성과 책임 영역을 안전하게 지킬 수 있다.

```java
public class User {
	private int private_id; // 외부에서 호출 시 에러 발생
	public int public_id;
}
```


### 2. 상속
상속이란 기존의 클래스를 재활용하여 새로운 클래스를 작성하는 문법 요소로, 상위 클래스로부터 확장된 하위 클래스들이 상위 클래스의 속성 & 기능들을 사용할 수 있도록 한다.

> NamePoint가 Point의 가면을 쓴 것 처럼 동작할 수 있는데, 이는 NamePoint가 순전히 Point를 포함하는 상위 집합으로, Point에 대응하는 멤버 변수의 순서가 그대로 유지되기 때문이다.

필자는 C언어 (절차지향프로그래밍) 시절에도 이런 OOP를 흉내내 사용한 기록이 있다는 점을 설명하고 있다.

### 3. 다형성
다형성이란 어떤 객체의 속성이나 기능이 상황에 따라 여러 형태를 가질 수 있는 성질을 의미한다.
대표적인 예로 메소드 오버라이딩과, 메소드 오버로딩이 있다.

> 말하려는 요지는 함수를 가리키는 포인터를 응용한 것이 다형성이라는 점이다.

OO 언어는 포인터를 초기화 해야하는 관례를 없앴다는 점에서 강력하다고 설명하고 있다. 제어흐름을 간접적으로 전환하는 규칙을 제공한 것이다.

> OO의 등장으로 언제 어디서든 플러그인 아키텍처를 적용할 수 있게 되었다.

다형성을 통해 프로그램은 다른 장치에서도 동일하게 동작할 수 있는 "독립성"을 이룰 수 있었다. 

### 의존성 역전(Dependency Inversion)
> 인터페이스 사이의 소스 코드 의존성(상속 관계)이 제어 흐름과는 반대인데, 이를 의존성 역전이라고 한다. OO언어가 다형성을 안전하고 편리하게 제공해 소스코드 의존성을 어디에서든 역전시킬 수 있게 되었다.

> 결과적으로 업무 규칙, UI, 데이터베이스는 세 가지고 분리된 컴포넌트 또는 배포 가능한 단위로 컴파일 할 수 있고, ... 독립적으로 배포할 수 있다. 이것이 바로 **배포 독립성**이다.
> 시스템 모듈을 독립적으로 배포할 수 있게 되면, 서로 다른 팀에서 각 모듈을 독립적으로 개발할 수 있다. 이것이 **개발 독립성**이다.

OO 아키텍트에서는 소스코드 의존성을 원하는 방향으로 설정할 수 있다고 설명한다.
좀 더 쉽게 설명하자면 보통 상위 컴포넌트에서 하위 컴포넌트를 사용하므로 제어 흐름이 상위 -> 하위로 향하게 되는데, **의존성은 반대로 하위 -> 상위로 향한다**. 따라서 원하는 방향으로 설정이 가능한 것이다!

```java
public class Kid {
    private Robot toy;

    public void setToy(Robot toy) {
        this.toy = toy; // 2. 상위 인터페이스를 호출한다.
    }

    public void play() {
        System.out.println(toy.toString());
    }
}
```

```java
public class Main{
    public static void main(String[] args) {
        Robot robot = new Robot();
        Kid k = new Kid(); // 1. 하위 모듈을 호출하는데
        k.setToy(robot);
        k.play();
    }
}
```

이런 의존성 역전을 사용하면 배포 독립성 특징을 지니게 되므로 각 팀에서 개별적으로 개발 할 수 있다는 장점이 있지만, 잘못 설계하게 되는 경우 변경이 너무 잦아지게 되어 악영향을 줄 수도 있다.

예를 들어, 위 코드에서 새로운 장난감 종류가 들어오게 된다면 Kib 클래스를 수정해줘야한다.
```java
public class Kid {

    private Robot toy;
    private Lego toy; //레고 추가
    
    // 아이가 가지고 노는 장난감의 종류만큼 Kid 클래스 내에 메서드가 존재해야함.
    public void setToy(Robot toy) {
        this.toy = toy;
    }
    public void setToy(Lego toy) {
        this.toy = toy;
    }

    public void play() {
        System.out.println(toy.toString());
    }
    
}
```
너무 변하기 쉬운 모듈(Robot)에 의존하면 클래스를 매번 수정해야하는 불편함이 있다.
따라서 의존성 역전 원칙을 준수하는 편이 좋다고 한다.

- **의존성 역전 원칙(DIP)**
	객체를 저수준 모듈(구현된 객체)보다 고수준 모듈(인터페이스 등의 객체나 추상적 개념 / 추상화)에 의존해야한다는 원칙
	
	DIP 원칙에 따르게 된다면 Kid 클래는 아래처럼 설계될 수 있다.
	```java
	public class Kid {
	    private Toy toy;
	
	    public void setToy(Toy toy) {
	        this.toy = toy;
	    }
	
	    public void play() {
	        System.out.println(toy.toString());
	    }
	```
	자세한 내용은 [이 블로그](https://velog.io/@harinnnnn/OOP-%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-5%EB%8C%80-%EC%9B%90%EC%B9%99SOLID-%EC%9D%98%EC%A1%B4%EC%84%B1-%EC%97%AD%EC%A0%84-%EC%9B%90%EC%B9%99-DIP)를 참고..

### 결론
OO를 사용하면 아키텍트는 **플러그인 아키텍처**를 구성할 수 있고, 이를 통해 고수준의 정책을 포함하는 모듈은 저수즌의 세부사항을 포함하는 모듈에 대해 **독립성을 보장**할 수 있다.


## 함수형 프로그래밍

> 클로저 프로그램에서는 이러한 가변 변수가 전혀 없다. 클로저에서는 x와 같은 변수가 한 번 초기화되면 절대로 변하지 않는다. 
> **함수형 언어에서 변수는 변경되지 않는다.**

뒤에 나오는 불변성을 설명하며 아래와 같이 설명한다.
> 우리가 동시성 애플리케이션에서 마주치는 모든 문제, 즉 다수의 스레드와 프로세스를 사용하는 애플리케이션에서 마주치는모든 문제는 가변 변수가 없다면 절대로 생기지 않는다.


### 가변성의 분리
> 불변 컴포넌트에서는 순수하게 함수형 방식으로만 작업이 처리되며, 어떤 가변 변수도 사용되지 않는다. 불변 컴포넌트는 변수의 상태를 변경할 수 있는, 즉 순수 함수형 컴포넌트가 아닌 하나 이상의 다른 컴포넌트와 서로 통신한다.
```js
// 가변 변수가 사용되지 않는 불변 컴포넌트
function makeCounter(x = 1) {
  return function() {
    return x++; //클로저로 가변변수를 보호 ??
  }
}

// 값을 변경하려면 반드시 counter를 호출해야한다. 
const counter = makeCounter();

console.log(counter()); // 1
console.log(counter()); // 2
```
🤔 책에 나왔던 불변성을 고려했을때, 위와같은 코드도 불변성을 유지한 코드가 된다고 볼 수 있을까??

> 현명한 아키텍트라면 가능한 한 많은 처리를 불변 컴포넌트로 옮겨야 하고, 가변 컴포넌트에서는 가능한 한 많은 코드를 빼내야한다.


### 이벤트 소싱
> 이벤트 소싱은 상태가 아닌 **트랜잭션을 저장**하자는 전략이다. 상태가 필요해지면 단순히 상태의 시작점부터 모든 트랜잭션을 처리한다.

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbF2oCK%2FbtrKdQ7nfTI%2FUJumUEpHkkUd7hZvF0kZGk%2Fimg.png" />
위처럼 저장함으로써 해당 상태가 된 이유를 설명할 수 있다는 장점을 가진다.
- [이벤트소싱](https://sabarada.tistory.com/231)

### 요약
아래와 같은 규율을 가진다.
- 구조적 프로그래밍 - 제어흐름의 직접적인 전환
- 객체지향 프로그래밍 - 제어흐름의 간접적인 전환(다형성!)
- 함수형 프로그래밍 - 변수할당

"소프트웨어, 즉 컴퓨터 프로그램은 순차, 분기, 반복, 참조로 구성된다. 그 이상도 이하도 아니다."

# Reference
- https://velog.io/@harinnnnn/OOP-%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-5%EB%8C%80-%EC%9B%90%EC%B9%99SOLID-%EC%9D%98%EC%A1%B4%EC%84%B1-%EC%97%AD%EC%A0%84-%EC%9B%90%EC%B9%99-DIP
- https://unknownpgr.com/posts/dependency-inversion/
