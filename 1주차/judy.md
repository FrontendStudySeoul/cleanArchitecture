## 1장. 설계와 아키텍처란?

- **아키텍처 :** 저수준의 세부사항과는 분리된 고수준의 무언가
- **설계 :** 저수준의 구조 또는 결정사항

> but, 저수준의 세부사항과 고수준의 결정사항은 전체 설계의 구성요소가 됨 → 둘을 구분 짓는 경계는 뚜렷하지 않고 고수준 → 저수준으로 향하는 의사경정의 연속성만 존재
> 

### 빨리 가는 유일한 방법은 제대로 가는 것이다.

- 소프트웨어 아키텍처의 목표는 필요한 시스템을 만들고 유지보수하는 데 투입되는 인력을 최소화하는 데 있다.
- 설계 품질을 재는 척도 = 고객의 요구를 만족시키는 데 드는 비용을 재는 척도 → 시스템의 수명이 다할 때까지 낮게 유지할 수 있는 것
- 엉망진찬 코드가 쌓이면 개발자 생산성 낮아진다. 우선 시장 출시가 먼저라는 생각에 엉망인 코드를 만들었을 때, task는 계속해서 생기니 엉망 코드를 정리하지 못하는 게 대다수임, 엉망으로 만들면 깔끔하게 유지하는 것보다 항상 더 느림
- 개발 조직이 할 수 있는 최고의 선택지는 조직에 스며든 과신을 인지하여 방지하고, 소프트웨어 아키텍처의 품질을 심각하게 고민하는 것. → 비용을 최소화하고 생산성은 최대화할 수 있는 좋은 소프트웨어 아키텍처가 뭐야? → 책에서 알려줄게

## 2장. 두 가지 가치에 대한 이야기

모든 소프트웨어 시스템은 이해관계자에게 행위와 구조를 제공해야함

### 행위
- 프로그래머 고용하는 이유 = 이해관계자를 위해 기계가 수익을 창출하거나 비용을 절약하도록 만들기 위해
- 기계가 요구사항 위반시, 프로그래머는 디버거를 열고 문제를 고침
- 많은 프로그래머들은 요구사항을 기계에 구현하고 버그를 수정하는 일이 자신의 직업이라 믿음 ⇒ 응 아니야

### 아키텍처
- 소프트웨어를 만든 이유는 기계의 행위를 쉽게 변경할 수 있도록 하기 위해서
- 이해관계자가 변경사항을 던지면 간단하고 쉽게 적용할 수 있어야함 → 적용하는 데 드는 어려움은 변경되는 범위에 비례해야 하며, 변경사항의 형태와는 관련이 없어야 한다.

- **소프트웨어 개발 비용 증가 원인 ⇒ 변경사항의 범위와 형태 ⇒ 변경사항의 크기**
- 아키텍처는 형태에 독립적이어야 하고, 그럴수록 더 실용적이다

### 더 높은 가치

기능인가 아키텍처인가? 
- 수정이 현실적으로 불가능한 시스템 → 변경에 드는 비용이 변경으로 창출되는 수익을 초과하는 경우
- 실질적으로 변경이 불가능한 상태에 처할 때까지 시스템을 방치하지 않도록..!

### 아이젠하위 매트릭스를 통한 우선순위
1. 긴급하고 중요한
2. 긴급하지는 않지만 중요한
3. 긴급하지만 중요하지 않은
4. 긴급하지도 중요하지도 않은

흔한 실수 3 → 1 격상, 기능의 긴급성이 아닌 아키텍처의 중요성을 설득!

> 여기서 많은 점을 느끼게 되었는데, 이슈가 빗발칠 때 가장 먼저 물어보는 것이 ‘**이거 급한건가요? 중요도는 어떻게 되나요?**’ 였다
> 
> 그리고 돌아오는 대답은 딱 위의 4가지와 흡사했다. 급하지만 중요하지 않거나 우회해서 사용이 가능한 기능이라면 백로그에 담아두고 나중에 시간이 남을 때 하나씩 쳐내갔다. 
> 

### 아키텍처를 위해 투쟁
- 아키텍처가 후순위가 되면 시스템을 개발하는 비용이 더 많이 들고, 일부 또는 전체 시스템에 변경을 가하는 일이 현실적으로 불가능해진다.

## 3장. 패러다임 개요

### **구조적 프로그래밍**

- 최초로 적용된 패러다임
- 무분별한 점프(`goto`)는 해롭다는 사실에서 출발
- `if`, `then`, `else`, `do`, `while`, `until`과 같은 구조로 대체
- 제어흐름의 직접적인 전환에 대해 규칙을 부과한다.

### 객체 지향 프로그래밍

- 함수 호출이 반환된 후에도 함수 내의 지역 변수가 유지될 수 있다는 개념에서 출발
- 제어흐름의 간접적인 전환에 대해 규칙을 부과한다.

### 함수형 프로그래밍

- 람다 계산법에서 출발 -> 불변성, 심볼의 값이 변경되지 않음
- 함수형 언어에는 할당문이 없음
- 변수 할당문에 대해 규칙을 부과한다.

> 각 패러다임은 무엇을 해야 할지를 말하기보다는 무엇을 해서는 안 되는지를 말해준다.
→ 우리에게서 goto문, 함수 포인터, 할당문을 앗아간다.

## 4장. 구조적 프로그래밍

### 증명

- 모든 프로그램은 **순차**, **분기**, **반복**이라는 세 가지 구조만으로 표현이 가능하다.
- 언어 자체에서 제어흐름을 제약 없이 직접 전환할 수 없으므로 우리는 모두 구조적 프로그래밍을 하고 있다.

### 기능적 분해
- `if`, `then`, `else`, `do`, `while`, `until`과 같은 분기와 반복을 사용해 모듈을 작은 단위로 쪼개고 분할 정복을 사용한다.
- 구조적 프로그래밍을 통해 재귀적으로 분해할 수 있게 되었고, 이로 인해 **모듈을 기능적으로 분해**할 수 있게 되었다.
    - 거대한 기술서를 받더라도 고수준의 기능들로 분해하고, 이를 또 저수준의 함수들로 분해하는 과정을 끝없이 반복하여 잘게 나눌 수 있다.
- 즉, 대규모 시스템을 **모듈**과 **컴포넌트**로 나누고 입증 가능한 아주 **작은 기능들로 세분화**할 수 있다.

### 테스트

- 테스트를 통해 프로그램이 맞다고 증명할 수는 없지만, 어딘가 잘못된 것을 찾아낼 수는 있다.
- 테스트가 보장할 수 있는 것은 **프로그램이 목표에 부합할 만큼은 충분히 참**이라고 여길 수 있게 하는 것이 전부이다.
- 분해된 기능들은 증명 가능한 단위가 되고, 이를 통해 테스트를 통해 기능이 거짓인지 증명할 수 있게 되었다.

### 결론
- 소프트웨어 아키텍트는 모듈, 컴포넌트, 서비스가 쉽게 반증 가능하도록(테스트하기 쉽도록) 만들기 위해 분주히 노력해야 한다.
- 아키텍처 관점에서 기능적 분해는 최고의 실천법 중 하나이다.

## 5장 객체 지향 프로그래밍
좋은 아키텍처를 만드는 일은 객체 지향 설계 원칙을 이해하고 응용하는 데서 출발

### 캡슐화
- 데이터와 함수가 응집력 있게 구성된 집단을 서로 구분 짓는 선을 그을 수 있다. 구분선 바깥에서 데이터는 은닉되고, 일부 함수만이 외부에 노출된다.

### 상속
- 단순히 어떤 변수와 함수를 하나의 유효 범위로 묶어서 재정의하는 일에 불과

### 다형성
- 함수를 가리키는 포인터를 응용한 것이 다형성이다.
- 플러그인 아키텍처로 기존 프로그램에 **손을 대지 않고도 손쉬운 확장**을 가능케 한다. -> 기존 구현의 변경 없이 새로운 기능을 추가할 수 있다.
- 유닉스 운영체제는 왜 입출력 장치들을 플러그인 형태로 만들었는가 ? -> 프로그램이 장치 독립적이어야 한다 -> 프로그램이 다른 장치에서도 동일하게 동작할 수 있도록 만드는 것이 진정 바라는 일
- 기존 코드 자체에서는 이미 고수준 객체로 동작에 초점을 맞춰 구현했기 때문에, 저수준 객체를 변경해주면 기존 코드 수정 없이 기능 변경이 가능하다. 
- 어떻게 고수준에서 저수준을 분리하여 기능만 명명해 사용이 가능하게 됐을까? -> 의존성 역전

### 의존성 역전
- 제어흐름은 시스템의 행위에 따라 결정되며, 소스코드 의존성은 제어흐름에 따라 결정된다
- 의존성 역전은 두 인터페이스 사이의 소스코드 의존성(상속관계)이 제어흐름과는 반대인 점을 뜻한다.
- 이는 추상화에 의존해야지, 구체화에 의존하면 안된다는 원칙이다.
- 즉 고수준 모듈은 저수준 모듈의 구현에 의존해서는 안된다. 대신 저수준 모듈이 고수준 모듈에서 정의한 추상 타입에 의존해야 한다.
<img width="696" alt="image" src="https://github.com/FrontendStudySeoul/cleanArchitecture/assets/70371342/913534f3-96c4-4f96-b557-866f2758936b">

- 객체 지향 언어가 다형성을 편리하고 안전하게 제공한다는 사실은 소스 코드의 의존성을 어디서든 역전시킬 수 있다는 의미이다. 인터페이스를 두어 의존성 역전 구조로 만들 수 있다.

### 결론
객체지향 프로그래밍은 다형성을 이용하여 고수준의 기능을 저수준의 구현체로부터 분리할 수 있게 해준다.
이를 통해 플러그인처럼 기능을 분리하여 저수준 모듈의 변경으로부터 자유로워진다.
저수준의 세부사항은 플러그인 모듈로 제작할 수 있고, 고수준의 정책을 포함하는 모듈에 독립적으로 개발하고 배포할 수 있다.

## 6장. 함수형 프로그래밍
함수형 프로그래밍에서 핵심 논제는 `변수는 불변성을 가진다` 이다. 변수가 가변적이면 프로그램 설계시 많은 고려사항이 있다.

### 불변성과 아키텍처
- 경쟁 조건, 교착 상태, 동시성 문제는 모두 가변 변수로 인해 발생한다.
- 그러나 우리는 모든 변수를 불변하게 유지할 수 없다. 그렇다면 어떻게 해야할까? -> 가변성의 분리

### 가변성의 분리
- 내부 서비스를 가변 컴포넌트와 불변 컴포넌트로 분리해 불변 컴포넌트에서는 함수형 방식으로만 작업을 처리한다. (가변 변수 X)
- 이 불변 컴포넌트는 변수의 상태를 변경할 수 있는 다른 컴포넌트와 통신한다.
- 현명한 아키텍트라면 가능한 많은 부분을 불변 컴포넌트로 분리하고, 가변 컴포넌트는 최소한으로 줄여야 한다.

### 이벤트 소싱
- 저장 공간과 처리 능력이 충분하면 완전한 불변성을 만들 수 있고, 완전한 함수형으로 만들 수 있다. 
- 저장과 처리공간에 대한 제약이 사라지면서, 실 데이터를 Update, Delete하는 것이 아닌, Select, Insert만 하는 방식이 등장했다. -> 이벤트 소싱
- 이벤트 소싱은 상태가 아닌 트랜잭션을 저장하여 상태가 필요해지는 순간 초기 상태에서 모든 실행된 트랜잭션을 추적하여 현재 값을 파악한다.

```
온라인 쇼핑몰에서 사용자가 상품을 검색하고, 장바구니에 담고, 결제하는 과정을 생각

1. 상품 검색 이벤트: 사용자가 특정 상품을 검색합니다. 이 때 발생하는 '상품 검색' 이벤트가 기록
2. 장바구니 추가 이벤트: 사용자가 상품을 장바구니에 담습니다. '장바구니 추가' 이벤트가 기록
3. 결제 이벤트: 사용자가 장바구니에 담긴 상품들에 대해 결제를 진행합니다. '결제' 이벤트가 기록

```
- 이벤트 소싱에서는 이러한 각 단계에서 발생하는 이벤트들을 모두 저장 -> 사용자의 최종 장바구니 상태나 구매 이력은 이러한 이벤트들을 순서대로 재현함으로써 얻어짐
- 사용자의 현재 장바구니 상태나 구매 이력은 저장되지 않고, 필요할 때마다 이벤트 로그를 통해 계산되어진다
- 이렇게 함으로써 데이터의 불변성이 보장되고, 시간에 따른 사용자의 행동을 정확히 추적할 수 있게 된다
- 이벤트 소싱은 데이터의 변경과 삭제가 없기 때문에, 동시성 문제나 데이터 일관성 문제를 최소화할 수 있다.
- 또한, 모든 이벤트가 기록되기 때문에, 시스템의 상태를 과거의 어느 시점으로도 복원할 수 있는 장점이 있다.

> 소프트웨어는 순차, 분기, 반복, 참조로 구성된다. 그 이상도 이하도 아니다. 

