# 클린 아키텍쳐
## 1장 설계와 아키텍쳐란?
- 아키텍쳐는 저수준의 세부사항과는 분리된 고수준의 무언가를 가르키는것.
- 설계는 저수준의 구조 또는 결정사항 등을 의미.
- 소프트웨어 아키텍쳐의 품질을 고민하지 않는다면 추후 생산성에 문제가 생길 수 있다.
- 이미 한번 작성된 코드는 정말 왠만해서는 바뀌지 않는다.

## 2징 두가지 가치에 대한 이야기
### 행위
프로그래머는 이해관계자가 기능 명세서나 요구사항 문서를 구체화할 수 있도록 돕는다. 이것이 프로그래머가 해야하는 전부라고 생각하지만 이것만 있는것은 아니다.
### 소프트웨어
소프트웨어는 부드러운(soft)과 제품(ware)의 합성어이다. 소프트웨어는 부드러움을 지니도록 만들어졌으며, 소프트웨어를 만든 이유는 기계의 행위를 **쉽게** 변경하기 위함이다.

<br>
아키텍쳐는 긴급하지 않지만 중요하며 이를 묵살하는순간 소프트웨어는 변경하기 어려워지며, 특히 **소프트웨어개발자**는 아키텍쳐가 두 배로 중요하다.
<br>
**이런 일이 발생하도록 용납했다면, 결국 소프트웨어 개발팀이 스스로 옳다는 가치를 위해 충분히 투쟁하지 않았다는 뜻이다.**

# 2부 벽돌부터 시작하기 : 프로그래밍 패러다임
## 3장 패러다임 개요
### 구조적 프로그래밍
구조적 프로그래밍은 제어흐름의 직접적인 전환에 대해 규칙을 부과한다
### 객체 지향 프로그래밍
객체 지향 프로그래밍은 제어흐름의 간접적인 전환에 대해 규칙을 부과한다.
### 함수형 프로그래밍
함수형 프로그래밍은 할당문에 대해 규칙을 부과한다.
### 생각할 거리
프로그래밍 패러다임은 프로그래머에게 새로운 권한을 주는게 아니라 하면 안될것을 정의하고 할 수 있는것을 박탈한다.
## 4장 구조적 프로그래밍
데이크스트라의 제시로 이뤄졌고 현대 언어에서는 제어흐름을 직접 제약할 수 없고 이런 선택권 자체를 언어에서 제공하지 않는다.
<br>
그래서 현대 프로그래머들은 모두 구조적 프로그래머라고 볼 수 있다.
<br>
프로그래밍은 과학이며 수학은 **증명가능한 서술이 참임을 입증하는 원리**이고, **과학은 증명가능한 서술이 거짓임을 입증하는 원리**이다.
### 테스트
위에서 말했던것처럼 과학은 증명가능한 서술이 거짓임을 입증하는 원리이기에 테스트도 어떤 프로그램이 문제(버그)가 있음을 증명할 수 있지만 맞다고는 증명할 수 없다.
<br>
구조적 프로그래밍은 증명 가능한 세부 기능 집합으러 재귀적으로 분해할 것을 강요한다. 그리하여 가장 작은 기능에서부터 가장 큰 컴포넌트까지
<br>
소프트웨어는 과학과 같고, 따라서 반증 가능성에 의해 주도된다.
<br>

## 5장 객체 지향 프로그래밍
좋은 아키텍쳐를 만드는 일은 객체지향 설계 원칙을 이해하고 응용하는 데서 출발한다.
### 캡슐화
OO(Object-Oriented)를 정의하는 요소 중 하나로 캡슐화를 언급하는 이유는 데이터와 함수를 쉽고 효과적으로 캡슐화하는 방법을 제공한다.
<br>
이 개념들이 실제 OO 언어에서는 각각 클래스의 private 멤버 데이터와 public 멤버 함수로 표현된다. 타입스크립트에는 다음과 같은 구분자가 있다.  ``public``, ``private``, ``protected``.
<br>
하지만 근대 언어에서는 엄격한 캡슐화를 약화하는 방향으로 발전했다.
- C++은 메모리 관리에 대해서 더 중요하게 생각하는 언어이므로 이러한 캡슐화가 약해지는 방향으로 발전했다.(제로 오버헤드 원리)[https://johngrib.github.io/wiki/jargon/zero-overhead-principle/]

### 상속
OO언어에서는 상속을 할 수 있는 방법을 상당히 편리한 방식으로 제공한다. ``Typescript에서는 extends메소드로 클래스를 상속 가능하다.`` <br>
정리하자면 OO언어는 캡슐화에서는 0점이고, 상속은 0.5점 정도이다.

### 다형성
다형성은 하나의 인터페이스나 추상 클래스로 여러가지 클래스를 구현할 수 있다.
<br>
그리고 다형성은 객체지향성에서 나온 이론은 아니고, OO를 지원하는 언어에서는 다형성을 쉽게할 수 있도록 도와줄 뿐이다.
```tsx
// 타입스크립트에서 다형성의 예시
interface Animal {
  makeSound(): void;
}

// Dog 클래스
class Dog implements Animal {
  makeSound() {
    console.log("멍멍");
  }
}

// Cat 클래스
class Cat implements Animal {
  makeSound() {
    console.log("야옹");
  }
}

// Cow 클래스
class Cow implements Animal {
  makeSound() {
    console.log("음메");
  }
}
```

### 다형성이 가진 힘
다형성 덕분에 우리는 장치에 의존적인 프로그램에서 장치에 독립적인 프로그램을 만들 수 있게 됐고 새로운 요구사항을 받아들일 수 있게 됐다.<br>
![image](https://github.com/FrontendStudySeoul/cleanArchitecture/assets/103626175/d1faf729-d546-4435-afd6-aaea7f7f77fa)<br>
이를 플러그인 아키텍쳐를 적용할 수 있는것이 OO언어에서의 다형성이다.

### 의존성 역전
다형성을 안전하고 편리하게 적용할 수 있는 메커니즘이 등장하기 전 소프트웨어는 다음과 같았다. main함수 -> 고수준 함수 -> 중간수준 함수<br>
![image](https://github.com/FrontendStudySeoul/cleanArchitecture/assets/103626175/0d9fc75f-0039-4db4-85c4-1f3b82932115)
<br>
이러한 제약 조건으로 인해 소프트웨어 아키텍트에는 남은 선택지가 별로 없었다.
<br>
![image](https://github.com/FrontendStudySeoul/cleanArchitecture/assets/103626175/ae784c85-ef1d-45d3-9471-0361090fa114)
<br>
위 사진이 의존성 역전이라고 부르는 대표적인 예시중 하나이다. OO언어가 다형성을 안전하고 편리하게 제공한다는 사실은 소스 코드 의존성을 어디에서든 역전시킬 수 있다는 뜻이다.

```tsx
// 데이터 서비스 인터페이스
interface DataService {
  fetchData(): Promise<any>;
}

// 실제 데이터 서비스 클래스
class MyDataService implements DataService {
  async fetchData() {
    // 데이터를 가져오는 비동기 작업 수행
    return await fetch('https://api.example.com/data');
  }
}

// 상위 수준 모듈
class App {
  private dataService: DataService;

  constructor(dataService: DataService) {
    this.dataService = dataService;
  }

  async loadData() {
    const data = await this.dataService.fetchData();
    // 데이터를 처리하는 로직
    console.log(data);
  }
}

// 애플리케이션 실행
const dataService = new MyDataService();
const app = new App(dataService);
app.loadData();
```
이를 통해 OO 언어로 개발된 시스템을 다루는 소프트웨어 아키텍트는 시스템의 소스 코드 ``의존성 전부에 대한 방향을 결정할 수 있는 절대적인 권한``을 갖는다.
<br>
특정 컴포넌트의 소스 코드가 변경되면, 해당 코드가 포함된 컴포넌트만 다시 배포하면 된다. 이것이 **배포 독립성**이다.
<br>
시스템의 모듈을 독립적으로 배포할 수 있게 되면, 서로 다른 팀에서 각 모듈을 독립적으로 개발할 수 있고, 이것이 **개발 독립성**이다.<br>
나는 이 글을 보고 프론트엔드에서 모노레포가 떠올랐다. 모노레포에서 공통 모듈은 각 서비스에 구애받지 않고 배포할 수 있다. 각 서비스에 의존하지 않는다.
<br>
그리고 각 서비스는 공통 모듈(lint, UI 컴포넌트, 비즈니스 로직 등)을 상속하여 독립적으로 배포한다.

### 결론
OO란 다형성을 이용하여 전체 시스템의 **모든 소스 코드 의존성에 대한 절대적인 제어 권한을 획들할 수 있는 능력**이다.
<br>
### 6장 함수형 프로그래밍
함수형 프로그래밍은 프로그래밍 그자체보다 앞서 등장했다.(함수형 프로그래밍이란?)[https://github.com/FrontendStudySeoul/SsogSsogFunctionalCoding/blob/main/1%EC%A3%BC%EC%B0%A8/moseung.md]
<br>

```tsx
import React, { useState } from 'react';

const CounterApp: React.FC = () => {
  // 상태 변수 count를 useState 훅을 사용하여 정의합니다.
  const [count, setCount] = useState<number>(0);

  // increment 함수는 클로저로 외부 상태 변수 count에 접근합니다.
  const increment = () => {
    setCount(prevCount => prevCount + 1); // 이전 상태 값을 기반으로 새로운 상태를 업데이트합니다.
  };

  return (
    <div>
      <h1>Counter App</h1>
      <p>Count: {count}</p>
      {/* 클릭 이벤트 핸들러로 increment 함수를 전달합니다. */}
      <button onClick={increment}>Increment</button>
    </div>
  );
};

export default CounterApp;

```
이 책에서는 클로저와 자바 프로그램 사이의 극단적인 차이를 짚는다.<br>
```java
public class Squint{
  public static void main(String args[]){
  for(int i=0; i<25; i++)
    System.out.printLn(i*i)
}
}
```
클로저 프로그램에서는 i의 값이 바뀌지 않고 이를 자바에선는 가변 변수라 한다. 즉 함수형  프로그래밍에서 변수는 한번 선언되면 절대 바뀌지 않는다.
### 불변성과 아키텍쳐
아키텍처를 고려할 때 이런 내용이 왜 중요한가? 경합조건, 교착상태 조건, 동시 업데이트 문제가 모두 가변 변수로 인해 발생한다.
<br>
즉 동시성 어플리케이션에서 마주치는 모든 문제, 즉 다수의 스레드와 프로세스를 사용하는 애플리케이션에서 마주치는 모든 문제는 가변 변수가 없으면 발생하지 않는다.
<br>
이런 문제는 저장 공간이 무한하고 프로세서의 속도가 무한히 빠르다면 괜찮으면 실현 가능하지만 일종의 타협이 필요하다.

### 가변성의 분리
불변성과 관련하여 주요 타협 중 하나는 애플리케이션에서 **불변, 가변의 컴포넌트로 분리가 필요하다.**
<br>
불변 컴포넌트에서는 순수하게 함수형 방식으로 작업을 처리하며, 가변 변수는 사용되지 않는다.<br>
상태 변경은 트랜잭션 메모리와 같은 실천법을 사용하여 가변 변수를 보호한다.
1. 원자성(Atomicity): 트랜잭션 메모리는 여러 개의 메모리 액세스를 하나의 원자적인 작업으로 처리합니다. 즉, 모든 액세스가 성공하거나 실패할 경우 모든 액세스가 취소됩니다.
2. 일관성(Consistency): 트랜잭션 메모리는 트랜잭션이 실행되는 동안에만 메모리의 일관성을 보장합니다. 즉, 다른 트랜잭션은 트랜잭션이 완료될 때까지 변경된 데이터를 볼 수 없습니다.
3. 격리성(Isolation): 트랜잭션 메모리는 여러 개의 트랜잭션이 동시에 실행될 때 각 트랜잭션 간의 상호 작용을 격리합니다. 즉, 한 트랜잭션의 작업이 다른 트랜잭션에 영향을 주지 않습니다.
4. 지속성(Durability): 트랜잭션 메모리는 트랜잭션이 완료된 후에도 변경된 데이터를 보존합니다. 즉, 시스템이 실패하거나 재부팅되어도 데이터는 손실되지 않습니다.
<br>
트랜잭션 메모리는 병행 프로그래밍 환경에서 데이터 무결성을 보장하고 동시성을 향상시키는데 사용됩니다. 다중 스레드 환경이나 분산 시스템에서 데이터의 안정성을 유지하기 위해 널리 사용되는 중요한 기술입니다.
<br>
현명한 아키텍트라면 가능한 많은 처리를 불변 컴포넌트로 옮겨야 하고, 가변 컴포넌트에서는 가능한 많은 코드를 빼내야한다.
<br>
<img width="563" alt="image" src="https://github.com/FrontendStudySeoul/cleanArchitecture/assets/103626175/5801f6b9-f2f0-42cd-aea7-d886d39256b7">

### 이벤트 소싱
저장 공간과 처리 능력의 한계는 우리의 시야에서 급격히 사라지고 있다.<br>
그래서 필요한 가변 상태가 더 적어졌다.
``트랜잭션: DB의 상태를 변경시키기 위해 수행하는 작업 단위``
<br>
이제 계좌 잔고를 변경하는 대신 트랜잭션 자체를 저장한다. 이러면 가변 변수가 하나도 필요 없다. 하지만 시간이 지날수록 트랜잭션 수는 끝없이 증가한다.
<br>
그렇지만 어플리케이션의 수명주기 동안만 문제없이 동작할 정도의 저장 공간과 처리 능력만 있으면 충분하다.
<br>
현대에서는 데이터 저장소의 발전으로 데이터 저장소에서 삭제되거나 변경되는것이 없다.
<br>
결과적으로 데이터 저장소에서 변경과 삭제가 발생하지 않으므로 동시성 문제 또한 해결된다. 저장 공간과 처리 능력이 충분하면 애플리케이션이 완전한 불변성을 갖도록 만들 수 있다.
<br>
소스 코드 버전 관리 시스템이 정확히 이 방식으로 동작한다. 즉 우리 소스코드에서 하나의 커밋이 하나의 트랜잭션이고 무한한 트랜잭션을 가지고 소스코드를 살리고 없애고 할 수 있다.
<br>
이를 로컬에서 저장하면 우리의 컴퓨터가 트랜잭션을 관리하는 주체이고 원격에서 하면 github,gitlab같은 곳이라 볼 수 있다.

### 결론
- 구조적 프로그래밍은 제어흐름의 직접적인 전환에 부과되는 규율.
- 객체 지향 프로그래밍은 제어흐름의 간접적인 전환(캡슐화, 상속, 다형성을 통한)에 부과되는 규율
- 함수형 프로그래밍은 변수 할당에 부과되는 규율
이러한 패러다임은 우리에게서 무언가를 앗아갔다.
그리고 소프트웨어는 순차,분기,반복,참조 그 이상도 이하도 아니다.




