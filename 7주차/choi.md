# 34장. 빠져  있는  장

# 계층 기반 패키지
- 수평적 계층화
- 가장 전통적이고 단순한 설계 방식
- 세 계층으로 구성
    - 웹 - Web
    - 업무 규칙 (Business Rules) - Service
    - 영속성 코드 - Repository
- 업무 도메인 간 차이점을 파악하기 어려움

![image](https://github.com/FrontendStudySeoul/cleanArchitecture/assets/25587196/830d5b0e-7583-4f8f-8ce6-6bbb4399b6b1)



# 기능 기반 패키지
- 수직적 계층화
- 연관 기능, 도메인 개념, Aggregate Root에 기반하여 수직의 얇은 조각으로 코드를 나누는 방식
- 모든 타입이 단 하나의 패키지에 속함
- 유스케이스(ex. 주문 조회기능)가 변경될 경우 변경해야 할 코드를 한 코드에서 관리 가능

![image](https://github.com/FrontendStudySeoul/cleanArchitecture/assets/25587196/88194418-0f42-4051-ba4e-95884eb4b9b3)


# 포트와 어댑터
  - 업무/도메인과 프레임워크/데이터베이스 사이 독립적이고 분리된 아키텍처 강조
  - 내부(도메인)과 외부(인프라)의 분리
      - 내부 : 업무/도메인 코드
      - 외부 : UI, DB, 서드파티 통합등  외부 세계와의 상호작용
  - 의존성은  반드시 외부가 내부에 의존.  반대는 불가.

![image](https://github.com/FrontendStudySeoul/cleanArchitecture/assets/25587196/41da7a6a-d82f-4ef5-8631-7cef32cb59ed)


# 컴포넌트 기반 패키지

- 계층형 아키텍처
    - 의존성 화살표가 항상 아래로 향해야 함 (비순환 의존성 그래프)
    - 각 계층은 반드시 바로 아래 계층에만 의존해야 함
- 이런 방식으로 깔끔한 비순환 의존성 그래프를 만들 수 있지만 코드베이스의 요소들이 서로 의존할 때는 몇가지 규칙을 반드시 지켜야함.
- 그러나 속임수를 써서 몇몇 의존성을 의도치 않은 방식으로 추가하더라도 여전히 좋은 비순환 의존성 그래프가 완성됨.
    
    → 신입사원의 완화된 계층형 아키텍처
      ![image](https://github.com/FrontendStudySeoul/cleanArchitecture/assets/25587196/e20a20cf-8986-49be-9b7b-22cc9ad5a3cf)

    
    - 여전히 의존성 화살표는 아래를 향하고 있지만 개별 레코드에 대해 인증된 접근만을 허용하는 일을 업무 로직이 책임지는 경우 바람직하지 못함.
    - 추가로 컨트롤러가 업무규칙을 포함하게되기 때문에 더더욱 올바르지 못함.
    - 여기서 필요한 지침 : "웹 컨트롤러는 절대로 레파지토리에 직접 접근해서는 안 된다"
- 컴포넌트 기반 패키지라는 접근법은 서비스 중심적인 시각으로 소프트웨어 시스템을 바라보며, MSA가 가진 시각과도 동일함.

# 조직화 vs 캡슐화

- 자바 애플리케이션에서 모든 타입을 public으로 지정한다면, 패키지는 단순히 조직화를 위한 매커니즘(폴더구조)으로 전락하여 캡슐화를 위한 메커니즘이 될수 없음.
- public 지시자를 과용하면 이 장의 앞에서 제시한 네 가지 아키텍처 접근법은 본질적으로 같아짐.
  ![image](https://github.com/FrontendStudySeoul/cleanArchitecture/assets/25587196/bf345138-60a5-4a53-91fe-00465229c775)
- 순서대로 계층기반 패키지, 기능기반 패키지, 업무도메인초점인 포트와 어댑터, 컴포넌트기반 패키지
- 각 타입의 화살표는 채택하려는 아키텍처 접근법과 상관없이 모두 동일한 방향을 가리킴
- 자바의 접근지시자를 적절하게 사용하면 타입을 패키지로 배치하는 방식에 따라서 각 타입에 접근할 수 있는 정도가 크게 달라짐. (public, protected)
  ![image](https://github.com/FrontendStudySeoul/cleanArchitecture/assets/25587196/8babcdba-7026-47c3-bdc4-071cac928459)

  
# 결론
### 고민해볼 사항
- 설계를 어떻게해야 원하는 코드 구조로 매핑가능한가?
- 해당 코드를 어떻게 조직화 할 것인가?
- 런타임, 컴파일타임에 어떤 결합 분리모드를 적용할것인가?

 

### 수행해야 할 사항
- 가능하면 선택사항은 열어두되 실용주의적으로 행해야함.
- 팀규모, 기술 수준, 해결책의 복잡성을 일정과 예산이라는 제약과 동시에 고려해야함.
- 선택한 아키텍처 스타일을 강제하는 데 컴파일러의 도움을 받을 수 있는지 고민해야함.
- 데이터 모델과 같은 영역에 결합되지 않도록 주의해야함.

 
