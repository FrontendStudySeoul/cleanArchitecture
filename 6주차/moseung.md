# 31장 데이터베이스는 세부사항이다.
아키텍처 관점에서 볼 떄 데이터베이스는 엔티티가 아니다. 즉, 데이터베이스는 세부사항이라서 아키텍처의 구성요소 수준을 끌어올릴 수 없다.<br>
데이터베이스는 데이터에 접근할 방법을 제공하는 유틸리티다. 아키텍처 관점에서 보면 이러한 유틸리티는 저수준의 세부사항(매커니즘)일 뿐이라서 아키텍처와는 관련이 없다.
![image](https://github.com/FrontendStudySeoul/cleanArchitecture/assets/103626175/04dbbf72-f5bb-44e6-a4c5-eccf1030c438)

## 관계형 데이터베이스
관계형 데이터베이스의 기술이 얼마나 뛰어나든, 유용하든, 아니면 수학적으로 견고하든, 결국은 그저 기술일 뿐이다. 그리고 이는 관계형 데이터베이스가 세부사항임을 뜻한다.
<br>
관계형 테이블은 특정한 형식의 데이터에 접근하는 경우에는 편리하지만, 데이터를 테이블에 행 단위로 배치단하는 자체는 아키텍처적으로 전혀 중요하지 않다.
### 관계형 데이터베이스를 대체할 수 있는것들 (NOSQL)
1. 문서 지향 데이터베이스(Document-Oriented Databases): 이 데이터베이스는 JSON, BSON, XML과 같은 형식의 문서를 저장하며, 문서는 키-값 쌍으로 구성된다. MongoDB와 CouchDB가 대표적
![image](https://github.com/FrontendStudySeoul/cleanArchitecture/assets/103626175/b2e632f7-63c6-4aa2-9a08-438b1bcb2ae0)
2. 키-값 저장소(Key-Value Stores): 가장 단순한 형태의 NoSQL 데이터베이스로, 키를 통해 데이터 값을 빠르게 검색할 수 있다. 예를 들어, Redis와 DynamoDB가 있다.
![image](https://github.com/FrontendStudySeoul/cleanArchitecture/assets/103626175/0cb673b1-25d4-46a4-a037-882a7a26573f)
3. 와이드 컬럼 스토어(Wide-Column Stores): 테이블의 각 행이 가질 수 있는 열의 수가 가변적인 데이터베이스이다. 이는 빅데이터를 처리하는 데 적합하며, Apache Cassandra와 HBase가 이 유형에 속한다.
![image](https://github.com/FrontendStudySeoul/cleanArchitecture/assets/103626175/9b150f3e-742a-4b71-aa36-6c9d2dc518a5)
4. 그래프 데이터베이스(Graph Databases): 엔티티(노드)들 사이의 관계(엣지)를 저장하는 데 특화된 데이터베이스이다. 복잡한 관계를 효율적으로 탐색할 수 있어 소셜 네트워크, 추천 시스템 등에 사용됩니다. Neo4j와 Amazon Neptune이 대표적이다.
![image](https://github.com/FrontendStudySeoul/cleanArchitecture/assets/103626175/28b4ffa4-94db-4cbe-806e-a10424d9fa73)

## 데이터베이스 시스템은 왜 이렇게 널리 사용되는가?
오라클, MySQL, SQL 서버가 우위를 차지할 수 있던 이유는 무엇일까? 한마디로 답하자면, 바로 '디스크'때문이었다.<br>
디스크때문에 피해갈 수 없는 시간 지연이라는 점을 완화하기 위해 색인, 캐시, 쿼리 계획 최적화가 필요해졌으며, 어떤 데이터인지 알아야했다. 그래서 데이터베이스 시스템이 등장했다.<br>
이 부분은 윈도우 HDD에서 내가 원하는 파일을 검색해보면 알 수 있다.

## 성능은?
데이터베이스의 성능은 중요하다. 하지만 이는 아키텍처와 분리해서 가져갈 수 있는 세부사항이다.

## 결론
체계화된 데이터 구조와 데이터 모델은 아키텍처적으로 중요하다. 반면 그저 데이터를 회전식 자기 디스크 표면에서 이리저리 옮길 뿐인 기술가 시스템은 아키텍처적으로 중요하지않다.<br>
데이터베이스는 세부사항일 뿐이다.

## 내 생각
최근 아는 프론트엔드 개발자분이랑 개발자의 이직에 대해서 얘기한적이 있는데 당시 프론트엔드 개발자의 도메인에 대해서 얘기가 나온 적 있다.<br>
백엔드 개발자는 특히 데이터의 구조와 즉 세부사항과 연관이 많기때문에 데이터의 구조와 연관이 깊은 도메인이 중요하다고 했다.<br>
그에 반해 프론트엔드 개발자 또한 웹 UI의 세부사항과 연관이 많지만 백엔드에 비해 상대적으로 도메인과 깊게 결합되지는 않는다고 했다.
### 옛날 API 서버 구조
그리고 옛날 백엔드 개발은 DB에서 데이터를 처리해서 API수준의 서버에서는 클라이언트의 요청에 따라 쿼리를 보내 가져오는 유연하게 처리하는 경우가 많았다.<br>
```
옛날 API 서버 아키텍처에서는 데이터베이스가 데이터 처리의 중심 역할을 맡는 경우가 많았습니다.
이러한 구조에서, 데이터베이스는 데이터의 저장, 검색, 수정, 삭제 등의 작업을 담당했으며, 서버는 사용자의 요청을 받아 데이터베이스에 쿼리를 보내 데이터를 검색하거나 업데이트한 후, 그 결과를 사용자에게 반환하는 역할을 주로 했습니다.

이러한 구조는 다음과 같은 특징을 가지고 있습니다

1. 중앙 집중화된 데이터 관리: 모든 데이터 관리 작업이 데이터베이스에서 이루어지므로, 데이터의 일관성과 무결성을 유지하기 쉽습니다.
2. 단순화된 서버 로직: 서버의 주 역할이 데이터베이스와의 통신 및 결과 반환에 초점을 맞추기 때문에, 서버의 개발 및 유지보수가 상대적으로 간단할 수 있습니다.

하지만, 이러한 구조는 또한 몇 가지 단점을 가지고 있습니다:

1. 데이터베이스의 과부하: 모든 데이터 처리 작업이 데이터베이스에서 이루어지기 때문에, 대규모 트래픽이 발생할 경우 데이터베이스에 과부하가 발생할 수 있습니다.
2. 확장성 문제: 데이터베이스가 처리 역량의 병목 지점이 되어 시스템의 전체적인 확장성이 제한될 수 있습니다.
3. 유연성 부족: 비즈니스 로직이 데이터베이스에 밀접하게 연결되어 있어, 비즈니스 요구사항이 변경될 경우 데이터베이스의 스키마 변경 등 큰 수정이 필요할 수 있습니다.

이러한 이유로, 현대의 API 서버 아키텍처는 종종 마이크로서비스, 서버리스 아키텍처와 같이 더 분산되고 확장성 있는 구조를 채택하고 있으며, 복잡한 비즈니스 로직 처리를 서버가 담당하고, 데이터베이스는 순수한 데이터 저장의 역할에 더 집중하는 경향이 있습니다.
```
